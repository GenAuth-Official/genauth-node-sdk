/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { AddGroupMembersReqDto } from "./models/AddGroupMembersReqDto";
import type { AddInvitationPolicyUserAttributionDto } from "./models/AddInvitationPolicyUserAttributionDto";
import type { AddInvitationPolicyUserAttributionsBatchDto } from "./models/AddInvitationPolicyUserAttributionsBatchDto";
import type { AddWhitelistDto } from "./models/AddWhitelistDto";
import type { AddWhitelistOfAppDto } from "./models/AddWhitelistOfAppDto";
import type { AdminAuditLogRespDto } from "./models/AdminAuditLogRespDto";
import type { ApplicationPaginatedRespDto } from "./models/ApplicationPaginatedRespDto";
import type { ApplicationSimpleInfoPaginatedRespDto } from "./models/ApplicationSimpleInfoPaginatedRespDto";
import type { ApplicationSimpleInfoSingleRespDto } from "./models/ApplicationSimpleInfoSingleRespDto";
import type { ApplicationSingleRespDto } from "./models/ApplicationSingleRespDto";
import type { AppListRespDto } from "./models/AppListRespDto";
import type { ApprovalUniversalInvitationApplicantDto } from "./models/ApprovalUniversalInvitationApplicantDto";
import type { AsaAccountListRespDto } from "./models/AsaAccountListRespDto";
import type { AsaAccountPaginatedRespDto } from "./models/AsaAccountPaginatedRespDto";
import type { AsaAccountSingleNullableRespDto } from "./models/AsaAccountSingleNullableRespDto";
import type { AsaAccountSingleRespDto } from "./models/AsaAccountSingleRespDto";
import type { AssignAsaAccountsDto } from "./models/AssignAsaAccountsDto";
import type { AssignRoleBatchDto } from "./models/AssignRoleBatchDto";
import type { AssignRoleDto } from "./models/AssignRoleDto";
import type { AuthorizeApplicationAccessDto } from "./models/AuthorizeApplicationAccessDto";
import type { AuthorizedResourceListRespDto } from "./models/AuthorizedResourceListRespDto";
import type { AuthorizedResourcePaginatedRespDto } from "./models/AuthorizedResourcePaginatedRespDto";
import type { AuthorizeResourcesDto } from "./models/AuthorizeResourcesDto";
import type { BatchBindPolicy } from "./models/BatchBindPolicy";
import type { BatchCreateDnefReq } from "./models/BatchCreateDnefReq";
import type { BatchUnbindPolicy } from "./models/BatchUnbindPolicy";
import type { ChangeExtIdpConnStateDto } from "./models/ChangeExtIdpConnStateDto";
import type { CheckDomainAvailable } from "./models/CheckDomainAvailable";
import type { CheckDomainAvailableSecretRespDto } from "./models/CheckDomainAvailableSecretRespDto";
import type { CheckExternalUserPermissionDto } from "./models/CheckExternalUserPermissionDto";
import type { CheckExternalUserPermissionRespDto } from "./models/CheckExternalUserPermissionRespDto";
import type { CheckParamsDataPolicyResponseDto } from "./models/CheckParamsDataPolicyResponseDto";
import type { CheckParamsDataResourceResponseDto } from "./models/CheckParamsDataResourceResponseDto";
import type { CheckPermissionDto } from "./models/CheckPermissionDto";
import type { CheckPermissionNamespaceExistsDto } from "./models/CheckPermissionNamespaceExistsDto";
import type { CheckPermissionRespDto } from "./models/CheckPermissionRespDto";
import type { CheckRoleMutualExclusionReqDto } from "./models/CheckRoleMutualExclusionReqDto";
import type { CheckRoleMutualExclusionRespDto } from "./models/CheckRoleMutualExclusionRespDto";
import type { CheckRoleParamsDto } from "./models/CheckRoleParamsDto";
import type { CheckSessionStatusDto } from "./models/CheckSessionStatusDto";
import type { CheckSessionStatusRespDto } from "./models/CheckSessionStatusRespDto";
import type { CheckUserSameLevelPermissionDto } from "./models/CheckUserSameLevelPermissionDto";
import type { CheckUserSameLevelPermissionResponseDto } from "./models/CheckUserSameLevelPermissionResponseDto";
import type { CommonResourcePaginatedRespDto } from "./models/CommonResourcePaginatedRespDto";
import type { CommonResponseDto } from "./models/CommonResponseDto";
import type { ConfigEmailProviderDto } from "./models/ConfigEmailProviderDto";
import type { CopyInvitationPolicyDto } from "./models/CopyInvitationPolicyDto";
import type { CopyRowRelationDto } from "./models/CopyRowRelationDto";
import type { CostGetAllRightItemRespDto } from "./models/CostGetAllRightItemRespDto";
import type { CostGetCurrentPackageRespDto } from "./models/CostGetCurrentPackageRespDto";
import type { CostGetCurrentUsageRespDto } from "./models/CostGetCurrentUsageRespDto";
import type { CostGetMauPeriodUsageHistoryRespDto } from "./models/CostGetMauPeriodUsageHistoryRespDto";
import type { CostGetOrderDetailRespDto } from "./models/CostGetOrderDetailRespDto";
import type { CostGetOrderPayDetailRespDto } from "./models/CostGetOrderPayDetailRespDto";
import type { CostGetOrdersRespDto } from "./models/CostGetOrdersRespDto";
import type { CreateAdminRoleDto } from "./models/CreateAdminRoleDto";
import type { CreateApplicationDto } from "./models/CreateApplicationDto";
import type { CreateApplicationRespDto } from "./models/CreateApplicationRespDto";
import type { CreateArrayDataResourceDto } from "./models/CreateArrayDataResourceDto";
import type { CreateArrayDataResourceResponseDto } from "./models/CreateArrayDataResourceResponseDto";
import type { CreateAsaAccountDto } from "./models/CreateAsaAccountDto";
import type { CreateAsaAccountsBatchDto } from "./models/CreateAsaAccountsBatchDto";
import type { CreateAuthorizeDataPolicyDto } from "./models/CreateAuthorizeDataPolicyDto";
import type { CreateDataPolicyDto } from "./models/CreateDataPolicyDto";
import type { CreateDataPolicyResponseDto } from "./models/CreateDataPolicyResponseDto";
import type { CreateDataResourceDto } from "./models/CreateDataResourceDto";
import type { CreateDataResourceResponseDto } from "./models/CreateDataResourceResponseDto";
import type { CreateDnefReq } from "./models/CreateDnefReq";
import type { CreateEventAppDto } from "./models/CreateEventAppDto";
import type { CreateExtIdpConnDto } from "./models/CreateExtIdpConnDto";
import type { CreateExtIdpDto } from "./models/CreateExtIdpDto";
import type { CreateFunctionModelDto } from "./models/CreateFunctionModelDto";
import type { CreateFunctionModelFieldDto } from "./models/CreateFunctionModelFieldDto";
import type { CreateGroupBatchReqDto } from "./models/CreateGroupBatchReqDto";
import type { CreateGroupReqDto } from "./models/CreateGroupReqDto";
import type { CreateInvitationPolicyDto } from "./models/CreateInvitationPolicyDto";
import type { CreateInvitationRosterDto } from "./models/CreateInvitationRosterDto";
import type { CreateNamespaceDto } from "./models/CreateNamespaceDto";
import type { CreateNamespacesBatchDto } from "./models/CreateNamespacesBatchDto";
import type { CreateOperateModelDto } from "./models/CreateOperateModelDto";
import type { CreateOrUpdateGroupReqDto } from "./models/CreateOrUpdateGroupReqDto";
import type { CreateOrUpdateGroupRespDto } from "./models/CreateOrUpdateGroupRespDto";
import type { CreatePermissionNamespaceDto } from "./models/CreatePermissionNamespaceDto";
import type { CreatePermissionNamespaceResponseDto } from "./models/CreatePermissionNamespaceResponseDto";
import type { CreatePermissionNamespacesBatchDto } from "./models/CreatePermissionNamespacesBatchDto";
import type { CreatePublicAccountBatchReqDto } from "./models/CreatePublicAccountBatchReqDto";
import type { CreatePublicAccountFromUserDto } from "./models/CreatePublicAccountFromUserDto";
import type { CreatePublicAccountReqDto } from "./models/CreatePublicAccountReqDto";
import type { CreateRelationValueDto } from "./models/CreateRelationValueDto";
import type { CreateResourceDto } from "./models/CreateResourceDto";
import type { CreateResourcesBatchDto } from "./models/CreateResourcesBatchDto";
import type { CreateRoleDto } from "./models/CreateRoleDto";
import type { CreateRolesBatch } from "./models/CreateRolesBatch";
import type { CreateRowDto } from "./models/CreateRowDto";
import type { CreateStringDataResourceDto } from "./models/CreateStringDataResourceDto";
import type { CreateStringDataResourceResponseDto } from "./models/CreateStringDataResourceResponseDto";
import type { CreateTreeDataResourceDto } from "./models/CreateTreeDataResourceDto";
import type { CreateTreeDataResourceResponseDto } from "./models/CreateTreeDataResourceResponseDto";
import type { CreateUEBADto } from "./models/CreateUEBADto";
import type { CreateUEBARespDto } from "./models/CreateUEBARespDto";
import type { CreateUserBatchReqDto } from "./models/CreateUserBatchReqDto";
import type { CreateUserReqDto } from "./models/CreateUserReqDto";
import type { CustomFieldListRespDto } from "./models/CustomFieldListRespDto";
import type { DefineEventDto } from "./models/DefineEventDto";
import type { DeleteAdminRoleDto } from "./models/DeleteAdminRoleDto";
import type { DeleteApplicationDto } from "./models/DeleteApplicationDto";
import type { DeleteAsaAccountBatchDto } from "./models/DeleteAsaAccountBatchDto";
import type { DeleteAsaAccountDto } from "./models/DeleteAsaAccountDto";
import type { DeleteAuthorizeDataPolicyDto } from "./models/DeleteAuthorizeDataPolicyDto";
import type { DeleteCommonResourcesBatchDto } from "./models/DeleteCommonResourcesBatchDto";
import type { DeleteCustomFieldsReqDto } from "./models/DeleteCustomFieldsReqDto";
import type { DeleteDataPolicyDto } from "./models/DeleteDataPolicyDto";
import type { DeleteDataResourceDto } from "./models/DeleteDataResourceDto";
import type { DeleteDeviceExclusiveValidScopeSettingsByIdsDto } from "./models/DeleteDeviceExclusiveValidScopeSettingsByIdsDto";
import type { DeleteDnefReq } from "./models/DeleteDnefReq";
import type { DeleteExtIdpConnDto } from "./models/DeleteExtIdpConnDto";
import type { DeleteExtIdpDto } from "./models/DeleteExtIdpDto";
import type { DeleteGroupsReqDto } from "./models/DeleteGroupsReqDto";
import type { DeleteInvitationPolicyByIdsDto } from "./models/DeleteInvitationPolicyByIdsDto";
import type { DeleteInvitationRosterBatchDto } from "./models/DeleteInvitationRosterBatchDto";
import type { DeleteInvitationRosterDto } from "./models/DeleteInvitationRosterDto";
import type { DeleteNamespaceDto } from "./models/DeleteNamespaceDto";
import type { DeleteNamespacesBatchDto } from "./models/DeleteNamespacesBatchDto";
import type { DeletePermissionNamespaceDto } from "./models/DeletePermissionNamespaceDto";
import type { DeletePermissionNamespacesBatchDto } from "./models/DeletePermissionNamespacesBatchDto";
import type { DeletePublicAccountsBatchDto } from "./models/DeletePublicAccountsBatchDto";
import type { DeleteResourceDto } from "./models/DeleteResourceDto";
import type { DeleteResourcesBatchDto } from "./models/DeleteResourcesBatchDto";
import type { DeleteRoleBatchDto } from "./models/DeleteRoleBatchDto";
import type { DeleteRoleDto } from "./models/DeleteRoleDto";
import type { DeleteRosterUsersDto } from "./models/DeleteRosterUsersDto";
import type { DeleteTerminalUserDto } from "./models/DeleteTerminalUserDto";
import type { DeleteUsersBatchDto } from "./models/DeleteUsersBatchDto";
import type { DeleteUserSyncRelationReqDto } from "./models/DeleteUserSyncRelationReqDto";
import type { DeleteWhitelistDto } from "./models/DeleteWhitelistDto";
import type { DeleteWhitelistOfAppDto } from "./models/DeleteWhitelistOfAppDto";
import type { DeviceStatusRespDto } from "./models/DeviceStatusRespDto";
import type { EmailProviderRespDto } from "./models/EmailProviderRespDto";
import type { EmailTemplateQueryDto } from "./models/EmailTemplateQueryDto";
import type { EmailTemplateSingleItemRespDto } from "./models/EmailTemplateSingleItemRespDto";
import type { EventAppPaginatedRespDto } from "./models/EventAppPaginatedRespDto";
import type { ExportMetadataDto } from "./models/ExportMetadataDto";
import type { ExportModelDto } from "./models/ExportModelDto";
import type { ExportUsersDto } from "./models/ExportUsersDto";
import type { ExtIdpConnDetailSingleRespDto } from "./models/ExtIdpConnDetailSingleRespDto";
import type { ExtIdpDetailSingleRespDto } from "./models/ExtIdpDetailSingleRespDto";
import type { ExtIdpListPaginatedRespDto } from "./models/ExtIdpListPaginatedRespDto";
import type { ExtIdpSingleRespDto } from "./models/ExtIdpSingleRespDto";
import type { FilterDto } from "./models/FilterDto";
import type { FunctionFieldListResDto } from "./models/FunctionFieldListResDto";
import type { FunctionModelFieldIdDto } from "./models/FunctionModelFieldIdDto";
import type { FunctionModelFieldResDto } from "./models/FunctionModelFieldResDto";
import type { FunctionModelIdDto } from "./models/FunctionModelIdDto";
import type { FunctionModelListDto } from "./models/FunctionModelListDto";
import type { FunctionModelOperateIdDto } from "./models/FunctionModelOperateIdDto";
import type { FunctionModelResDto } from "./models/FunctionModelResDto";
import type { FunctionModelValueListResDto } from "./models/FunctionModelValueListResDto";
import type { FunctionModelValueResDto } from "./models/FunctionModelValueResDto";
import type { GenerateInvitationLinkRespDto } from "./models/GenerateInvitationLinkRespDto";
import type { GetAdminAuditLogsDto } from "./models/GetAdminAuditLogsDto";
import type { GetAllRowByScrollidResDto } from "./models/GetAllRowByScrollidResDto";
import type { GetAllRowDto } from "./models/GetAllRowDto";
import type { GetAllRowVyScrollidDto } from "./models/GetAllRowVyScrollidDto";
import type { GetApplicationPermissionStrategyRespDto } from "./models/GetApplicationPermissionStrategyRespDto";
import type { GetApplicationSecretRespDto } from "./models/GetApplicationSecretRespDto";
import type { GetAsaAccountAssignedTargetRespDto } from "./models/GetAsaAccountAssignedTargetRespDto";
import type { GetAsaAccountBatchDto } from "./models/GetAsaAccountBatchDto";
import type { GetCustomDataRespDto } from "./models/GetCustomDataRespDto";
import type { GetDataPolicyResponseDto } from "./models/GetDataPolicyResponseDto";
import type { GetDataResourceResponseDto } from "./models/GetDataResourceResponseDto";
import type { GetDeviceExclusiveRuleRespDto } from "./models/GetDeviceExclusiveRuleRespDto";
import type { GetDeviceExclusiveValidScopeAppRespDto } from "./models/GetDeviceExclusiveValidScopeAppRespDto";
import type { GetDeviceExclusiveValidScopeRespDto } from "./models/GetDeviceExclusiveValidScopeRespDto";
import type { GetDeviceExclusiveWhiteListRespDto } from "./models/GetDeviceExclusiveWhiteListRespDto";
import type { GetEmailTemplateRespDto } from "./models/GetEmailTemplateRespDto";
import type { GetEmailTemplatesRespDto } from "./models/GetEmailTemplatesRespDto";
import type { GetExtendsFieldsRespDto } from "./models/GetExtendsFieldsRespDto";
import type { GetExternalUserResourceStructDto } from "./models/GetExternalUserResourceStructDto";
import type { GetExternalUserResourceStructRespDto } from "./models/GetExternalUserResourceStructRespDto";
import type { GetImportExportTemplateRespDto } from "./models/GetImportExportTemplateRespDto";
import type { GetImportInviteeRespDto } from "./models/GetImportInviteeRespDto";
import type { GetImportTemplateResDto } from "./models/GetImportTemplateResDto";
import type { GetInvitationPolicyRespDto } from "./models/GetInvitationPolicyRespDto";
import type { GetMapInfoRespDto } from "./models/GetMapInfoRespDto";
import type { GetOtpSecretRespDto } from "./models/GetOtpSecretRespDto";
import type { GetPermissionNamespaceListResponseDto } from "./models/GetPermissionNamespaceListResponseDto";
import type { GetPermissionNamespaceResponseDto } from "./models/GetPermissionNamespaceResponseDto";
import type { GetRelationInfoDto } from "./models/GetRelationInfoDto";
import type { GetResourceAuthorizedTargetRespDto } from "./models/GetResourceAuthorizedTargetRespDto";
import type { GetResourceAuthorizedTargetsDto } from "./models/GetResourceAuthorizedTargetsDto";
import type { GetRowBatchDto } from "./models/GetRowBatchDto";
import type { GetSubjectAuthRespDto } from "./models/GetSubjectAuthRespDto";
import type { GetUniversalInvitationRespDto } from "./models/GetUniversalInvitationRespDto";
import type { GetUserActionLogsDto } from "./models/GetUserActionLogsDto";
import type { GetUserEncryptPasswordBatchDto } from "./models/GetUserEncryptPasswordBatchDto";
import type { GetUserEncryptPasswordBatchRespDto } from "./models/GetUserEncryptPasswordBatchRespDto";
import type { GetUserPasswordCiphertextDto } from "./models/GetUserPasswordCiphertextDto";
import type { GetUserPasswordCiphertextRespDto } from "./models/GetUserPasswordCiphertextRespDto";
import type { GetUserPermissionListDto } from "./models/GetUserPermissionListDto";
import type { GetUserPermissionListRespDto } from "./models/GetUserPermissionListRespDto";
import type { GetUserResourcePermissionListDto } from "./models/GetUserResourcePermissionListDto";
import type { GetUserResourcePermissionListRespDto } from "./models/GetUserResourcePermissionListRespDto";
import type { GetUserResourceStructDto } from "./models/GetUserResourceStructDto";
import type { GetUserResourceStructRespDto } from "./models/GetUserResourceStructRespDto";
import type { GetWechatAccessTokenDto } from "./models/GetWechatAccessTokenDto";
import type { GetWechatAccessTokenInfoRespDto } from "./models/GetWechatAccessTokenInfoRespDto";
import type { GroupListRespDto } from "./models/GroupListRespDto";
import type { GroupPaginatedRespDto } from "./models/GroupPaginatedRespDto";
import type { GroupSingleRespDto } from "./models/GroupSingleRespDto";
import type { HasAnyRoleReqDto } from "./models/HasAnyRoleReqDto";
import type { HasAnyRoleRespDto } from "./models/HasAnyRoleRespDto";
import type { IdentityListRespDto } from "./models/IdentityListRespDto";
import type { ImportMetadataDto } from "./models/ImportMetadataDto";
import type { ImportModelDto } from "./models/ImportModelDto";
import type { ImportOtpReqDto } from "./models/ImportOtpReqDto";
import type { ImportUsersDto } from "./models/ImportUsersDto";
import type { InvitationRosterPaginationRespDto } from "./models/InvitationRosterPaginationRespDto";
import type { InvitationRosterSingleRespDto } from "./models/InvitationRosterSingleRespDto";
import type { InvitationUserPaginationRespDto } from "./models/InvitationUserPaginationRespDto";
import type { IpListCreateDto } from "./models/IpListCreateDto";
import type { IpListPaginatedRespDto } from "./models/IpListPaginatedRespDto";
import type { IsActionAllowedDto } from "./models/IsActionAllowedDto";
import type { IsActionAllowedRespDtp } from "./models/IsActionAllowedRespDtp";
import type { IsSuccessDto } from "./models/IsSuccessDto";
import type { IsSuccessRespDto } from "./models/IsSuccessRespDto";
import type { IsUserExistsReqDto } from "./models/IsUserExistsReqDto";
import type { IsUserExistsRespDto } from "./models/IsUserExistsRespDto";
import type { KickPublicAccountsDto } from "./models/KickPublicAccountsDto";
import type { KickUsersDto } from "./models/KickUsersDto";
import type { LinkIdentityDto } from "./models/LinkIdentityDto";
import type { LinkIdentityResDto } from "./models/LinkIdentityResDto";
import type { ListApplicationActiveUsersDto } from "./models/ListApplicationActiveUsersDto";
import type { ListApplicationAuthDto } from "./models/ListApplicationAuthDto";
import type { ListApplicationAuthPaginatedRespDto } from "./models/ListApplicationAuthPaginatedRespDto";
import type { ListApplicationSubjectRespDto } from "./models/ListApplicationSubjectRespDto";
import type { ListArchivedUsersSingleRespDto } from "./models/ListArchivedUsersSingleRespDto";
import type { ListAuthSubjectDto } from "./models/ListAuthSubjectDto";
import type { ListCistomFieldsResDto } from "./models/ListCistomFieldsResDto";
import type { ListDataPoliciesPaginatedRespDto } from "./models/ListDataPoliciesPaginatedRespDto";
import type { ListDataPolicySubjectPaginatedRespDto } from "./models/ListDataPolicySubjectPaginatedRespDto";
import type { ListDataResourcesPaginatedRespDto } from "./models/ListDataResourcesPaginatedRespDto";
import type { ListDnefPaginatedRespDto } from "./models/ListDnefPaginatedRespDto";
import type { ListInvitationRosterByPolicyIdDto } from "./models/ListInvitationRosterByPolicyIdDto";
import type { ListInvitationRosterDto } from "./models/ListInvitationRosterDto";
import type { ListInvitationUserDto } from "./models/ListInvitationUserDto";
import type { ListPermissionViewDto } from "./models/ListPermissionViewDto";
import type { ListPermissionViewResponseDto } from "./models/ListPermissionViewResponseDto";
import type { ListPublicAccountsRequestDto } from "./models/ListPublicAccountsRequestDto";
import type { ListResourceTargetsDto } from "./models/ListResourceTargetsDto";
import type { ListResourceTargetsRespDto } from "./models/ListResourceTargetsRespDto";
import type { ListSimpleDataPoliciesPaginatedRespDto } from "./models/ListSimpleDataPoliciesPaginatedRespDto";
import type { ListUsersRequestDto } from "./models/ListUsersRequestDto";
import type { MetadataGroupDto } from "./models/MetadataGroupDto";
import type { MetadataListResDto } from "./models/MetadataListResDto";
import type { MFADisableSettingsDto } from "./models/MFADisableSettingsDto";
import type { MFASettingsDto } from "./models/MFASettingsDto";
import type { MFASettingsRespDto } from "./models/MFASettingsRespDto";
import type { NamespaceListPaginatedRespDto } from "./models/NamespaceListPaginatedRespDto";
import type { NamespaceListRespDto } from "./models/NamespaceListRespDto";
import type { NamespaceRespDto } from "./models/NamespaceRespDto";
import type { NamespaceRolesListPaginatedRespDto } from "./models/NamespaceRolesListPaginatedRespDto";
import type { OpenEventPaginatedRespDto } from "./models/OpenEventPaginatedRespDto";
import type { OperateModelDto } from "./models/OperateModelDto";
import type { PaginationInvitationPolicyQueryDto } from "./models/PaginationInvitationPolicyQueryDto";
import type { PaginationInvitationPolicyRespDto } from "./models/PaginationInvitationPolicyRespDto";
import type { PaginationUniversalInvitationApplicantQueryDto } from "./models/PaginationUniversalInvitationApplicantQueryDto";
import type { PaginationUniversalInvitationApplicantRespDto } from "./models/PaginationUniversalInvitationApplicantRespDto";
import type { PermissionNamespaceCheckExistsRespDto } from "./models/PermissionNamespaceCheckExistsRespDto";
import type { PermissionNamespaceListPaginatedRespDto } from "./models/PermissionNamespaceListPaginatedRespDto";
import type { PermissionNamespaceRolesListPaginatedRespDto } from "./models/PermissionNamespaceRolesListPaginatedRespDto";
import type { PolicyExtendsFieldsDto } from "./models/PolicyExtendsFieldsDto";
import type { PreviewEmailTemplateDto } from "./models/PreviewEmailTemplateDto";
import type { PreviewEmailTemplateRespDto } from "./models/PreviewEmailTemplateRespDto";
import type { PrincipalAuthenticationInfoPaginatedRespDto } from "./models/PrincipalAuthenticationInfoPaginatedRespDto";
import type { PubEventDto } from "./models/PubEventDto";
import type { PubEventRespDto } from "./models/PubEventRespDto";
import type { PublicAccountListRespDto } from "./models/PublicAccountListRespDto";
import type { PublicAccountPaginatedRespDto } from "./models/PublicAccountPaginatedRespDto";
import type { PublicAccountSingleRespDto } from "./models/PublicAccountSingleRespDto";
import type { QuickFilterInvitationUserDto } from "./models/QuickFilterInvitationUserDto";
import type { QuickFilterInviteePaginationRespDto } from "./models/QuickFilterInviteePaginationRespDto";
import type { RefreshApplicationSecretDto } from "./models/RefreshApplicationSecretDto";
import type { RefreshApplicationSecretRespDto } from "./models/RefreshApplicationSecretRespDto";
import type { RelationSearchDto } from "./models/RelationSearchDto";
import type { RelationValueListResDto } from "./models/RelationValueListResDto";
import type { RemoveGroupMembersReqDto } from "./models/RemoveGroupMembersReqDto";
import type { RemoveInvitationPolicyUserAttributionDto } from "./models/RemoveInvitationPolicyUserAttributionDto";
import type { RemoveInvitationPolicyUserAttributionsBatchDto } from "./models/RemoveInvitationPolicyUserAttributionsBatchDto";
import type { RemoveRelationValueDto } from "./models/RemoveRelationValueDto";
import type { RemoveRowDto } from "./models/RemoveRowDto";
import type { ResetUserPrincipalAuthenticationInfoDto } from "./models/ResetUserPrincipalAuthenticationInfoDto";
import type { ResourceListRespDto } from "./models/ResourceListRespDto";
import type { ResourcePaginatedRespDto } from "./models/ResourcePaginatedRespDto";
import type { ResourceRespDto } from "./models/ResourceRespDto";
import type { RevertRosterInvitationBatchDto } from "./models/RevertRosterInvitationBatchDto";
import type { RevertRosterInvitationDto } from "./models/RevertRosterInvitationDto";
import type { RevokeApplicationAccessDto } from "./models/RevokeApplicationAccessDto";
import type { RevokeRoleBatchDto } from "./models/RevokeRoleBatchDto";
import type { RevokeRoleDto } from "./models/RevokeRoleDto";
import type { RiskListPolicyCreateDto } from "./models/RiskListPolicyCreateDto";
import type { RoleAuthorizedResourcePaginatedRespDto } from "./models/RoleAuthorizedResourcePaginatedRespDto";
import type { RoleCheckParamsRespDto } from "./models/RoleCheckParamsRespDto";
import type { RoleListPageRespDto } from "./models/RoleListPageRespDto";
import type { RolePaginatedRespDto } from "./models/RolePaginatedRespDto";
import type { RoleSingleRespDto } from "./models/RoleSingleRespDto";
import type { SaveDeviceExclusiveValidScopeSettingsDto } from "./models/SaveDeviceExclusiveValidScopeSettingsDto";
import type { SecuritySettingsRespDto } from "./models/SecuritySettingsRespDto";
import type { SendRosterInvitationBatchDto } from "./models/SendRosterInvitationBatchDto";
import type { SendRosterInvitationDto } from "./models/SendRosterInvitationDto";
import type { SetCustomDataReqDto } from "./models/SetCustomDataReqDto";
import type { SetCustomFieldsReqDto } from "./models/SetCustomFieldsReqDto";
import type { SetMfaStatusDto } from "./models/SetMfaStatusDto";
import type { SetPublicAccountBatchReqDto } from "./models/SetPublicAccountBatchReqDto";
import type { SetUserBaseFieldsReqDto } from "./models/SetUserBaseFieldsReqDto";
import type { SetUserGroupsDto } from "./models/SetUserGroupsDto";
import type { SetUserOfPublicAccountBatchReqDto } from "./models/SetUserOfPublicAccountBatchReqDto";
import type { SetUserRolesDto } from "./models/SetUserRolesDto";
import type { SuspendTerminalUserDto } from "./models/SuspendTerminalUserDto";
import type { SyncRelationListRespDto } from "./models/SyncRelationListRespDto";
import type { TerminalBaseDto } from "./models/TerminalBaseDto";
import type { UnbindPublicAccountBatchReqDto } from "./models/UnbindPublicAccountBatchReqDto";
import type { UnlinkIdentity } from "./models/UnlinkIdentity";
import type { UnlinkIdentityResDto } from "./models/UnlinkIdentityResDto";
import type { UpdateApplicationDto } from "./models/UpdateApplicationDto";
import type { UpdateApplicationMfaSettingsDto } from "./models/UpdateApplicationMfaSettingsDto";
import type { UpdateApplicationPermissionStrategyDataDto } from "./models/UpdateApplicationPermissionStrategyDataDto";
import type { UpdateAsaAccountDto } from "./models/UpdateAsaAccountDto";
import type { UpdateAuthEnabledDto } from "./models/UpdateAuthEnabledDto";
import type { UpdateDataPolicyDto } from "./models/UpdateDataPolicyDto";
import type { UpdateDataPolicyResponseDto } from "./models/UpdateDataPolicyResponseDto";
import type { UpdateDataResourceDto } from "./models/UpdateDataResourceDto";
import type { UpdateDataResourceResponseDto } from "./models/UpdateDataResourceResponseDto";
import type { UpdateDeviceExclusiveRuleDto } from "./models/UpdateDeviceExclusiveRuleDto";
import type { UpdateDnefReq } from "./models/UpdateDnefReq";
import type { UpdateEmailTemplateDto } from "./models/UpdateEmailTemplateDto";
import type { UpdateExtIdpConnDto } from "./models/UpdateExtIdpConnDto";
import type { UpdateExtIdpDto } from "./models/UpdateExtIdpDto";
import type { UpdateFunctionModelDto } from "./models/UpdateFunctionModelDto";
import type { UpdateFunctionModelFieldDto } from "./models/UpdateFunctionModelFieldDto";
import type { UpdateGroupReqDto } from "./models/UpdateGroupReqDto";
import type { UpdateInvitationPolicyDto } from "./models/UpdateInvitationPolicyDto";
import type { UpdateInvitationRosterDto } from "./models/UpdateInvitationRosterDto";
import type { UpdateLoginConfigDto } from "./models/UpdateLoginConfigDto";
import type { UpdateNamespaceDto } from "./models/UpdateNamespaceDto";
import type { UpdateNamespaceRespDto } from "./models/UpdateNamespaceRespDto";
import type { UpdateOperateModelDto } from "./models/UpdateOperateModelDto";
import type { UpdatePermissionNamespaceDto } from "./models/UpdatePermissionNamespaceDto";
import type { UpdatePermissionNamespaceResponseDto } from "./models/UpdatePermissionNamespaceResponseDto";
import type { UpdatePublicAccountBatchReqDto } from "./models/UpdatePublicAccountBatchReqDto";
import type { UpdatePublicAccountReqDto } from "./models/UpdatePublicAccountReqDto";
import type { UpdateResourceDto } from "./models/UpdateResourceDto";
import type { UpdateRoleDto } from "./models/UpdateRoleDto";
import type { UpdateRowDto } from "./models/UpdateRowDto";
import type { UpdateSecuritySettingsDto } from "./models/UpdateSecuritySettingsDto";
import type { UpdateTerminalUserDto } from "./models/UpdateTerminalUserDto";
import type { UpdateUniversalInvitationDto } from "./models/UpdateUniversalInvitationDto";
import type { UpdateUserBatchReqDto } from "./models/UpdateUserBatchReqDto";
import type { UpdateUserReqDto } from "./models/UpdateUserReqDto";
import type { UserActionLogRespDto } from "./models/UserActionLogRespDto";
import type { UserAttributionPaginationRespDto } from "./models/UserAttributionPaginationRespDto";
import type { UserAttributionSingleRespDto } from "./models/UserAttributionSingleRespDto";
import type { UserFieldDecryptReqDto } from "./models/UserFieldDecryptReqDto";
import type { UserFieldDecryptRespDto } from "./models/UserFieldDecryptRespDto";
import type { UserListCreateDto } from "./models/UserListCreateDto";
import type { UserListPaginatedRespDto } from "./models/UserListPaginatedRespDto";
import type { UserListPolicyPaginatedRespDto } from "./models/UserListPolicyPaginatedRespDto";
import type { UserListRespDto } from "./models/UserListRespDto";
import type { UserLoggedInAppsListRespDto } from "./models/UserLoggedInAppsListRespDto";
import type { UserLoggedInIdentitiesRespDto } from "./models/UserLoggedInIdentitiesRespDto";
import type { UserLoginHistoryPaginatedRespDto } from "./models/UserLoginHistoryPaginatedRespDto";
import type { UserMfaSingleRespDto } from "./models/UserMfaSingleRespDto";
import type { UserPaginatedRespDto } from "./models/UserPaginatedRespDto";
import type { UserSingleRespDto } from "./models/UserSingleRespDto";
import type { WhitelistListRespDto } from "./models/WhitelistListRespDto";
import type { CreateTerminalDto } from "./models/CreateTerminalDto";
import type { QueryTerminalAppsDto } from "./models/QueryTerminalAppsDto";
import type { TerminalInfoRespDto } from "./models/TerminalInfoRespDto";
import type { CreatePipelineFunctionDto } from "./models/CreatePipelineFunctionDto";
import type { DeletePipelineFunctionDto } from "./models/DeletePipelineFunctionDto";
import type { PipelineFunctionPaginatedRespDto } from "./models/PipelineFunctionPaginatedRespDto";
import type { PipelineFunctionSingleRespDto } from "./models/PipelineFunctionSingleRespDto";
import type { ReUploadPipelineFunctionDto } from "./models/ReUploadPipelineFunctionDto";
import type { UpdatePipelineFunctionDto } from "./models/UpdatePipelineFunctionDto";
import type { UpdatePipelineOrderDto } from "./models/UpdatePipelineOrderDto";
import type { CreateWebhookDto } from "./models/CreateWebhookDto";
import type { CreateWebhookRespDto } from "./models/CreateWebhookRespDto";
import type { DeleteWebhookDto } from "./models/DeleteWebhookDto";
import type { GetWebhookRespDto } from "./models/GetWebhookRespDto";
import type { GetWebhooksRespDto } from "./models/GetWebhooksRespDto";
import type { ListWebhookLogs } from "./models/ListWebhookLogs";
import type { ListWebhookLogsRespDto } from "./models/ListWebhookLogsRespDto";
import type { TriggerWebhookDto } from "./models/TriggerWebhookDto";
import type { TriggerWebhookRespDto } from "./models/TriggerWebhookRespDto";
import type { UpdateWebhookDto } from "./models/UpdateWebhookDto";
import type { UpdateWebhooksRespDto } from "./models/UpdateWebhooksRespDto";
import type { WebhookEventListRespDto } from "./models/WebhookEventListRespDto";
import type { CreateAccessKeyDto } from "./models/CreateAccessKeyDto";
import type { CreateAccessKeyResponseDto } from "./models/CreateAccessKeyResponseDto";
import type { DeleteAccessKeyDto } from "./models/DeleteAccessKeyDto";
import type { GetAccessKeyResponseDto } from "./models/GetAccessKeyResponseDto";
import type { ListAccessKeyResponseDto } from "./models/ListAccessKeyResponseDto";
import type { UpdateAccessKeyDto } from "./models/UpdateAccessKeyDto";
import type { ApplicationDto } from "./models/ApplicationDto";

import {
  DEFAULT_OPTIONS,
  ManagementClientOptions,
} from "./ManagementClientOptions";
import { ManagementHttpClient } from "./ManagementHttpClient";
import { domainC14n } from "./utils";
import Axios, { AxiosRequestConfig } from "axios";
import WebSocket from "ws";
import { buildAuthorization, buildStringToSign } from "./utils/buildSignature";
const pkg = require("../package.json");

export class ManagementClient {
  private httpClient: ManagementHttpClient;
  private options: ManagementClientOptions;
  private wsMap: {
    [propName: string]: {
      socket: WebSocket;
      lockConnect: boolean;
      timeConnect: number;
    };
  };
  private eventBus: { [propName: string]: [Function, Function][] };
  constructor(options: ManagementClientOptions) {
    Object.keys(options).forEach(
      (i: any) =>
        typeof (options as any)[i] !== "number" &&
        !(options as any)[i] &&
        delete (options as any)[i]
    );
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    Axios.defaults.baseURL = domainC14n(String(this.options.host));
    this.httpClient = new ManagementHttpClient(this.options);
    this.wsMap = {};
    this.eventBus = {};

    if (!this.options.accessKeyId) {
      throw new Error("accessKeyId is required");
    }

    if (!this.options.accessKeySecret) {
      throw new Error("accessKeySecret is required");
    }
  }

  public async makeRequest(params: AxiosRequestConfig) {
    return await this.httpClient.request(params);
  }

  /**
   * @summary Advanced search for data objects
   * @description Advanced search for data objects
   * @returns FunctionModelValueListResDto
   */
  public async listRow(
    requestBody: FilterDto
  ): Promise<FunctionModelValueListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/filter",
      data: requestBody,
    });
  }

  /**
   * @summary Get data object row information
   * @description Get data object row information
   * @returns FunctionModelValueResDto
   */
  public async getRow({
    modelId,
    rowId,
    showFieldId = "false",
  }: {
    /** Function ID **/
    modelId: string;
    /** Row ID **/
    rowId: string;
    /** Whether to use field ID as key in response **/
    showFieldId?: string;
  }): Promise<FunctionModelValueResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-row",
      params: {
        modelId: modelId,
        rowId: rowId,
        showFieldId: showFieldId,
      },
    });
  }

  /**
   * @summary Get data object row information by property value
   * @description Get data object row information by property value, only allows exact query through unique fields.
   * @returns FunctionModelValueResDto
   */
  public async getRowByValue({
    modelId,
    key,
    value,
    showFieldId = "false",
  }: {
    /** Function ID **/
    modelId: string;
    /** Field key **/
    key: string;
    /** Field value **/
    value: string;
    /** Whether to use field ID as key in response **/
    showFieldId?: string;
  }): Promise<FunctionModelValueResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-row-by-value",
      params: {
        modelId: modelId,
        key: key,
        value: value,
        showFieldId: showFieldId,
      },
    });
  }

  /**
   * @summary Get batch row information
   * @description Get batch row information
   * @returns MetadataListResDto
   */
  public async getRowBatch(
    requestBody: GetRowBatchDto
  ): Promise<MetadataListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/get-row-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Add row
   * @description Add row
   * @returns FunctionModelValueResDto
   */
  public async createRow(
    requestBody: CreateRowDto
  ): Promise<FunctionModelValueResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/create-row",
      data: requestBody,
    });
  }

  /**
   * @summary Update row
   * @description Update row
   * @returns FunctionModelValueResDto
   */
  public async updateRow(
    requestBody: UpdateRowDto
  ): Promise<FunctionModelValueResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/update-row",
      data: requestBody,
    });
  }

  /**
   * @summary Delete row
   * @description Delete row
   * @returns CommonResponseDto
   */
  public async removeRow(
    requestBody: RemoveRowDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/remove-row",
      data: requestBody,
    });
  }

  /**
   * @summary Create data object
   * @description Use this interface to create a custom data object and define its basic information
   * @returns FunctionModelResDto
   */
  public async createModel(
    requestBody: CreateFunctionModelDto
  ): Promise<FunctionModelResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/create-model",
      data: requestBody,
    });
  }

  /**
   * @summary Get data object details
   * @description Get detailed information of the data object using the function ID
   * @returns FunctionModelResDto
   */
  public async getModel({
    id,
  }: {
    /** Function ID can be obtained from the console page **/
    id: string;
  }): Promise<FunctionModelResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-model",
      params: {
        id: id,
      },
    });
  }

  /**
   * @summary Get data object list
   * @description Get data object list
   * @returns FunctionModelListDto
   */
  public async listModel(): Promise<FunctionModelListDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/list-model",
    });
  }

  /**
   * @summary Delete data object
   * @description Delete the corresponding data object based on the requested function ID
   * @returns CommonResponseDto
   */
  public async removeModel(
    requestBody: FunctionModelIdDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/remove-model",
      data: requestBody,
    });
  }

  /**
   * @summary Update data object
   * @description Update the data object information for the corresponding function ID
   * @returns FunctionModelResDto
   */
  public async updateModel(
    requestBody: UpdateFunctionModelDto
  ): Promise<FunctionModelResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/update-model",
      data: requestBody,
    });
  }

  /**
   * @summary Create field for data object
   * @description Create fields for related data objects, configure field information and basic validation rules
   * @returns FunctionModelFieldResDto
   */
  public async createField(
    requestBody: CreateFunctionModelFieldDto
  ): Promise<FunctionModelFieldResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/create-field",
      data: requestBody,
    });
  }

  /**
   * @summary Update field for data object
   * @description Update field information and basic validation rules for related data objects
   * @returns FunctionModelFieldResDto
   */
  public async updateField(
    requestBody: UpdateFunctionModelFieldDto
  ): Promise<FunctionModelFieldResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/update-field",
      data: requestBody,
    });
  }

  /**
   * @summary Delete field from data object
   * @description Delete the corresponding field based on function field ID, function ID, and field property name
   * @returns CommonResponseDto
   */
  public async remoteField(
    requestBody: FunctionModelFieldIdDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/remove-field",
      data: requestBody,
    });
  }

  /**
   * @summary Get data object field list
   * @description Get data object field list
   * @returns FunctionFieldListResDto
   */
  public async listField({
    modelId,
    from,
  }: {
    /** Function ID **/
    modelId: string;
    /** Request source **/
    from: string;
  }): Promise<FunctionFieldListResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/list-field",
      params: {
        modelId: modelId,
        from: from,
      },
    });
  }

  /**
   * @summary Export all data
   * @description Export all data
   * @returns CommonResponseDto
   */
  public async exportMetadata(
    requestBody: ExportModelDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/export",
      data: requestBody,
    });
  }

  /**
   * @summary Import data
   * @description Import data
   * @returns CommonResponseDto
   */
  public async importMetadata(
    requestBody: ImportModelDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/import",
      data: requestBody,
    });
  }

  /**
   * @summary Get import template
   * @description Get import template
   * @returns GetImportTemplateResDto
   */
  public async getImportTemplate({
    modelId,
  }: {
    /** Function ID **/
    modelId: string;
  }): Promise<GetImportTemplateResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-import-template",
      params: {
        modelId: modelId,
      },
    });
  }

  /**
   * @summary Create custom operation
   * @description Create custom operation
   * @returns CommonResponseDto
   */
  public async createOperate(
    requestBody: CreateOperateModelDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/create-operate",
      data: requestBody,
    });
  }

  /**
   * @summary Remove custom operation
   * @description Remove custom operation
   * @returns CommonResponseDto
   */
  public async removeOperate(
    requestBody: FunctionModelOperateIdDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/remove-operate",
      data: requestBody,
    });
  }

  /**
   * @summary Execute custom operation
   * @description Execute custom operation
   * @returns CommonResponseDto
   */
  public async executeOperate(
    requestBody: FunctionModelOperateIdDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/execute-operate",
      data: requestBody,
    });
  }

  /**
   * @summary Copy custom operation
   * @description Copy custom operation
   * @returns CommonResponseDto
   */
  public async copyOperate(
    requestBody: FunctionModelOperateIdDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/copy-operate",
      data: requestBody,
    });
  }

  /**
   * @summary Operation management list (paginated)
   * @description Operation management list (paginated)
   * @returns OperateModelDto
   */
  public async listOperate({
    modelId,
    keywords,
    fieldId,
    showCreated,
    page = 1,
    limit = 10,
  }: {
    /** Model ID **/
    modelId: string;
    /** Search function name **/
    keywords?: string;
    /** Associated field ID **/
    fieldId?: string;
    /** Whether to return user-created operations, only valid when fieldId is provided **/
    showCreated?: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number of items per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<OperateModelDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/list-operate",
      params: {
        keywords: keywords,
        modelId: modelId,
        fieldId: fieldId,
        showCreated: showCreated,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary All operation management list
   * @description All operation management list
   * @returns OperateModelDto
   */
  public async listOperateAll({
    modelId,
  }: {
    /** Model ID **/
    modelId: string;
  }): Promise<OperateModelDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/all-operate",
      params: {
        modelId: modelId,
      },
    });
  }

  /**
   * @summary Update operation management
   * @description Update operation management
   * @returns CommonResponseDto
   */
  public async updateOperate(
    requestBody: UpdateOperateModelDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/update-operate",
      data: requestBody,
    });
  }

  /**
   * @summary Get relation data details
   * @description Get relation data details
   * @returns CommonResponseDto
   */
  public async getRelationInfo(
    requestBody: GetRelationInfoDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/get-relation-info",
      data: requestBody,
    });
  }

  /**
   * @summary Create row relation data
   * @description Create row relation data
   * @returns CommonResponseDto
   */
  public async createRowRelation(
    requestBody: CreateRelationValueDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/create-row-relation",
      data: requestBody,
    });
  }

  /**
   * @summary Get row relation data
   * @description Get row relation data
   * @returns RelationValueListResDto
   */
  public async getRelationValue({
    modelId,
    fieldId,
    rowId,
    page = 1,
    limit = 10,
  }: {
    /** Function ID **/
    modelId: string;
    /** Field ID **/
    fieldId: string;
    /** Row ID **/
    rowId: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number of items per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<RelationValueListResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-row-relation",
      params: {
        modelId: modelId,
        fieldId: fieldId,
        rowId: rowId,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Delete row relation data
   * @description Delete row relation data
   * @returns CommonResponseDto
   */
  public async removeRelationValue(
    requestBody: RemoveRelationValueDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/remove-row-relation",
      data: requestBody,
    });
  }

  /**
   * @summary Export data object
   * @description Export data object
   * @returns CommonResponseDto
   */
  public async exportModel(
    requestBody: ExportMetadataDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/export/model",
      data: requestBody,
    });
  }

  /**
   * @summary Import data object
   * @description Import data object
   * @returns CommonResponseDto
   */
  public async importModel(
    requestBody: ImportMetadataDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/import/model",
      data: requestBody,
    });
  }

  /**
   * @summary Get all data object data
   * @description Get all data object data
   * @returns FunctionModelValueListResDto
   */
  public async getAllMetadata(
    requestBody: GetAllRowDto
  ): Promise<FunctionModelValueListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/get-all-metadata",
      data: requestBody,
    });
  }

  /**
   * @summary Get row relation data
   * @description Get row relation data
   * @returns RelationValueListResDto
   */
  public async getRelationDetails(): Promise<RelationValueListResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/metadata/get-row-relation-details",
    });
  }

  /**
   * @summary Fuzzy search for relation
   * @description Fuzzy search for relation
   * @returns RelationValueListResDto
   */
  public async relationSearch(
    requestBody: RelationSearchDto
  ): Promise<RelationValueListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/relation-search",
      data: requestBody,
    });
  }

  /**
   * @summary Copy row relation
   * @description Copy row relation to other relations
   * @returns RelationValueListResDto
   */
  public async copyRowRelation(
    requestBody: CopyRowRelationDto
  ): Promise<RelationValueListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/copy-row-relation",
      data: requestBody,
    });
  }

  /**
   * @summary Get all metadata row information
   * @description Get all metadata row information by scrollid
   * @returns GetAllRowByScrollidResDto
   */
  public async getAllMetadataRow(
    requestBody: GetAllRowVyScrollidDto
  ): Promise<GetAllRowByScrollidResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/get-all-row-by-scrollid",
      data: requestBody,
    });
  }

  /**
   * @summary Get metadata related group information
   * @description Get metadata related group information
   * @returns FunctionModelValueListResDto
   */
  public async getMetadataGroupList(
    requestBody: MetadataGroupDto
  ): Promise<FunctionModelValueListResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/group",
      data: requestBody,
    });
  }

  /**
   * @summary UEBA upload
   * @description UEBA upload
   * @returns CreateUEBARespDto
   */
  public async capture(requestBody: CreateUEBADto): Promise<CreateUEBARespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/metadata/ueba/capture",
      data: requestBody,
    });
  }

  /**
   * @summary Remove binding (user details page)
   * @description Remove binding (user details page).
   * @returns CommonResponseDto
   */
  public async deleteDevice(
    requestBody: DeleteTerminalUserDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-device-by-user",
      data: requestBody,
    });
  }

  /**
   * @summary Suspend device (user details page)
   * @description Suspend device (user details page).
   * @returns CommonResponseDto
   */
  public async suspendDevice(
    requestBody: SuspendTerminalUserDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/suspend-device-by-user",
      data: requestBody,
    });
  }

  /**
   * @summary Disable device (user details page)
   * @description Disable device (user details page).
   * @returns CommonResponseDto
   */
  public async disableDevice(
    requestBody: UpdateTerminalUserDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/disable-device-by-user",
      data: requestBody,
    });
  }

  /**
   * @summary Enable device (user details page)
   * @description Enable device (user details page).
   * @returns CommonResponseDto
   */
  public async enableDevice(
    requestBody: UpdateTerminalUserDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/enable-device-by-user",
      data: requestBody,
    });
  }

  /**
   * @summary Get device status
   * @description Get device status.
   * @returns DeviceStatusRespDto
   */
  public async getDeviceStatus(
    requestBody: TerminalBaseDto
  ): Promise<DeviceStatusRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/device-status",
      data: requestBody,
    });
  }

  /**
   * @summary Get/search public account list
   * @description
   * This interface is used to get the user list, supports fuzzy search, and filters users through dimensions such as user basic fields, user custom fields, and user historical login applications.
   *
   * ### Fuzzy search example
   *
   * By default, fuzzy search will perform fuzzy search on users from five fields: `phone`, `email`, `name`, `username`, `nickname`. You can also decide the range of fuzzy matching fields by setting `options.fuzzySearchOn`:
   *
   * ```json
   * {
   * "keywords": "Beijing",
   * "options": {
   * "fuzzySearchOn": [
   * "address"
   * ]
   * }
   * }
   * ```
   *
   * ### Advanced search example
   *
   * You can perform advanced search through `advancedFilter`. Advanced search supports filtering users through dimensions such as user basic information, custom data, user source, login application, external identity source information.
   * **And these filter conditions can be combined arbitrarily.**
   *
   * #### Filter disabled users
   *
   * User status (`status`) is a string type, with optional values of `Activated` and `Suspended`:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "status",
   * "operator": "EQUAL",
   * "value": "Suspended"
   * }
   * ]
   * }
   * ```
   *
   * #### Filter users whose email contains `@example.com`
   *
   * User email (`email`) is a string type and can be fuzzy searched:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "email",
   * "operator": "CONTAINS",
   * "value": "@example.com"
   * }
   * ]
   * }
   * ```
   *
   * #### Search based on any extension field of the user
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "some-custom-key",
   * "operator": "EQUAL",
   * "value": "some-value"
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by number of user logins
   *
   * Filter users with more than 10 logins:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loginsCount",
   * "operator": "GREATER",
   * "value": 10
   * }
   * ]
   * }
   * ```
   *
   * Filter users with 10-100 logins:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loginsCount",
   * "operator": "BETWEEN",
   * "value": [10, 100]
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by user's last login time
   *
   * Filter users who have logged in within the last 7 days:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "lastLoginTime",
   * "operator": "GREATER",
   * "value": new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
   * }
   * ]
   * }
   * ```
   *
   * Filter users who have logged in during a certain time period:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "lastLogin",
   * "operator": "BETWEEN",
   * "value": [
   * Date.now() - 14 * 24 * 60 * 60 * 1000,
   * Date.now() - 7 * 24 * 60 * 60 * 1000
   * ]
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by applications users have logged into
   *
   * Filter users who have logged into application `appId1` or `appId2`:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loggedInApps",
   * "operator": "IN",
   * "value": [
   * "appId1",
   * "appId2"
   * ]
   * }
   * ]
   * }
   * ```
   *
   *
   *
   * @returns PublicAccountPaginatedRespDto
   */
  public async listPublicAccounts(
    requestBody: ListPublicAccountsRequestDto
  ): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-public-accounts",
      data: requestBody,
    });
  }

  /**
   * @summary Get public account information
   * @description Get public account details through public account user ID, you can choose to get custom data, select specified user ID type, etc.
   * @returns PublicAccountSingleRespDto
   */
  public async getPublicAccount({
    userId,
    userIdType = "user_id",
    withCustomData = false,
  }: {
    /** Public account user ID **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, like `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponds to `externalId` field in GenAuth user information
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Whether to get custom data **/
    withCustomData?: boolean;
  }): Promise<PublicAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-public-account",
      params: {
        userId: userId,
        userIdType: userIdType,
        withCustomData: withCustomData,
      },
    });
  }

  /**
   * @summary Batch get public account information
   * @description Batch get public account information through public account user ID list, you can choose to get custom data, select specified user ID type, etc.
   * @returns PublicAccountListRespDto
   */
  public async getPublicAccountBatch({
    userIds,
    userIdType = "user_id",
    withCustomData = false,
  }: {
    /** Public account user ID array **/
    userIds: Array<string>;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, like `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponds to `externalId` field in GenAuth user information
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Whether to get custom data **/
    withCustomData?: boolean;
  }): Promise<PublicAccountListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-public-account-batch",
      params: {
        userIds: userIds,
        userIdType: userIdType,
        withCustomData: withCustomData,
      },
    });
  }

  /**
   * @summary Create public account
   * @description Create public account, email, phone number, username must contain one of them, email, phone number, username, externalId are unique in the user pool, this interface will create public account users as administrator so no need for phone verification code and other security checks.
   * @returns PublicAccountSingleRespDto
   */
  public async createPublicAccount(
    requestBody: CreatePublicAccountReqDto
  ): Promise<PublicAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-public-account",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create public accounts
   * @description Batch create public accounts, email, phone number, username must contain one of them, email, phone number, username, externalId are unique in the user pool, this interface will create public account users as administrator so no need for phone verification code and other security checks.
   * @returns PublicAccountListRespDto
   */
  public async createPublicAccountsBatch(
    requestBody: CreatePublicAccountBatchReqDto
  ): Promise<PublicAccountListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-public-accounts-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Update public account information
   * @description Update public account information through public account user ID, email, phone number, username, externalId are unique in the user pool, this interface will modify public account information as administrator so no need for phone verification code and other security checks.
   * @returns PublicAccountSingleRespDto
   */
  public async updatePublicAccount(
    requestBody: UpdatePublicAccountReqDto
  ): Promise<PublicAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-public-account",
      data: requestBody,
    });
  }

  /**
   * @summary Batch update public account information
   * @description Batch update public account information, email, phone number, username, externalId are unique in the user pool, this interface will modify public account information as administrator so no need for phone verification code and other security checks.
   * @returns PublicAccountListRespDto
   */
  public async updatePublicAccountBatch(
    requestBody: UpdatePublicAccountBatchReqDto
  ): Promise<PublicAccountListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-public-account-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete public accounts
   * @description Delete public accounts through public account ID list, supports batch deletion, can select specified user ID type, etc.
   * @returns IsSuccessRespDto
   */
  public async deletePublicAccountsBatch(
    requestBody: DeletePublicAccountsBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-public-accounts-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Force logout public accounts
   * @description Force public accounts to logout through public account ID, App ID list, can select specified public account ID type, etc.
   * @returns IsSuccessRespDto
   */
  public async kickPublicAccounts(
    requestBody: KickPublicAccountsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/kick-public-accounts",
      data: requestBody,
    });
  }

  /**
   * @summary Convert personal account to public account
   * @description Convert personal account to public account through user ID.
   * @returns IsSuccessRespDto
   */
  public async changeIntoPublicAccount(
    requestBody: CreatePublicAccountFromUserDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/transfer-into-public-account",
      data: requestBody,
    });
  }

  /**
   * @summary Get user's public account list
   * @description Get user's public account list through user ID.
   * @returns PublicAccountPaginatedRespDto
   */
  public async getPublicAccountsOfUser({
    userId,
  }: {
    /** User ID **/
    userId: string;
  }): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-public-accounts-of-user",
      params: {
        userId: userId,
      },
    });
  }

  /**
   * @summary User list of public account
   * @description Get user list through public account ID.
   * @returns PublicAccountPaginatedRespDto
   */
  public async getUsersOfPublicAccount({
    publicAccountId,
  }: {
    /** Public account ID **/
    publicAccountId: string;
  }): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-users-of-public-account",
      params: {
        publicAccountId: publicAccountId,
      },
    });
  }

  /**
   * @summary Public account binds batch users
   * @description Use public account to bind batch users
   * @returns IsSuccessRespDto
   */
  public async bindUsersPublicAccount(
    requestBody: SetPublicAccountBatchReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-public-account-of-users",
      data: requestBody,
    });
  }

  /**
   * @summary User binds batch public accounts
   * @description User binds batch public accounts
   * @returns IsSuccessRespDto
   */
  public async setuserOfPublicAccount(
    requestBody: SetUserOfPublicAccountBatchReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-user-of-public-accounts",
      data: requestBody,
    });
  }

  /**
   * @summary Public account unbinds user
   * @description Public account unbinds user
   * @returns IsSuccessRespDto
   */
  public async unbindUsersPublicAccount(
    requestBody: UnbindPublicAccountBatchReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/unbind-public-account-of-user",
      data: requestBody,
    });
  }

  /**
   * @summary Get/search user list
   * @description
   * This interface is used to get the user list, supports fuzzy search, and filters users through dimensions such as user basic fields, user custom fields, and user historical login applications.
   *
   * ### Fuzzy search example
   *
   * By default, fuzzy search will perform fuzzy search on users from five fields: `phone`, `email`, `name`, `username`, `nickname`. You can also decide the range of fuzzy matching fields by setting `options.fuzzySearchOn`:
   *
   * ```json
   * {
   * "keywords": "Beijing",
   * "options": {
   * "fuzzySearchOn": [
   * "address"
   * ]
   * }
   * }
   * ```
   *
   * ### Advanced search example
   *
   * You can perform advanced search through `advancedFilter`. Advanced search supports filtering users through dimensions such as user basic information, custom data, user source, login application, external identity source information.
   * **And these filter conditions can be combined arbitrarily.**
   *
   * #### Filter disabled users
   *
   * User status (`status`) is a string type, with optional values of `Activated` and `Suspended`:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "status",
   * "operator": "EQUAL",
   * "value": "Suspended"
   * }
   * ]
   * }
   * ```
   *
   * #### Filter users whose email contains `@example.com`
   *
   * User email (`email`) is a string type and can be fuzzy searched:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "email",
   * "operator": "CONTAINS",
   * "value": "@example.com"
   * }
   * ]
   * }
   * ```
   *
   * #### Search based on any extension field of the user
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "some-custom-key",
   * "operator": "EQUAL",
   * "value": "some-value"
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by number of user logins
   *
   * Filter users with more than 10 logins:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loginsCount",
   * "operator": "GREATER",
   * "value": 10
   * }
   * ]
   * }
   * ```
   *
   * Filter users with 10-100 logins:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loginsCount",
   * "operator": "BETWEEN",
   * "value": [10, 100]
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by user's last login time
   *
   * Filter users who have logged in within the last 7 days:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "lastLoginTime",
   * "operator": "GREATER",
   * "value": new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
   * }
   * ]
   * }
   * ```
   *
   * Filter users who have logged in during a certain time period:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "lastLogin",
   * "operator": "BETWEEN",
   * "value": [
   * Date.now() - 14 * 24 * 60 * 60 * 1000,
   * Date.now() - 7 * 24 * 60 * 60 * 1000
   * ]
   * }
   * ]
   * }
   * ```
   *
   * #### Filter by applications users have logged into
   *
   * Filter users who have logged into application `appId1` or `appId2`:
   *
   * ```json
   * {
   * "advancedFilter": [
   * {
   * "field": "loggedInApps",
   * "operator": "IN",
   * "value": [
   * "appId1",
   * "appId2"
   * ]
   * }
   * ]
   * }
   * ```
   *
   *
   *
   * @returns UserPaginatedRespDto
   */
  public async listUsers(
    requestBody: ListUsersRequestDto
  ): Promise<UserPaginatedRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-users",
      data: requestBody,
    });
  }

  /**
   * @deprecated
   * @summary Get user list
   * @description Get user list interface, supports pagination, can choose to get custom data, identities, etc.
   * @returns UserPaginatedRespDto
   */
  public async listUsersLegacy({
    page = 1,
    limit = 10,
    status,
    updatedAtStart,
    updatedAtEnd,
    withCustomData = false,
    withIdentities = false,
    withUserPasswordExpireTime = false,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Current account status, such as Suspended, Resigned, Activated, Archived **/
    status?:
      | "Suspended"
      | "Resigned"
      | "Activated"
      | "Archived"
      | "Deactivated";
    /** User creation, modification start time, UNIX timestamp accurate to seconds; supports getting incremental data after a certain time **/
    updatedAtStart?: number;
    /** User creation, modification end time, UNIX timestamp accurate to seconds; supports getting incremental data within a certain time period. Default is current time **/
    updatedAtEnd?: number;
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to get identities **/
    withIdentities?: boolean;
    /** Whether to get user password expiration time **/
    withUserPasswordExpireTime?: boolean;
  }): Promise<UserPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-users",
      params: {
        page: page,
        limit: limit,
        status: status,
        updatedAtStart: updatedAtStart,
        updatedAtEnd: updatedAtEnd,
        withCustomData: withCustomData,
        withIdentities: withIdentities,
        withUserPasswordExpireTime: withUserPasswordExpireTime,
      },
    });
  }

  /**
   * @summary Get user information
   * @description Get user details by user ID, you can choose to get custom data, identities, and specify user ID type.
   * @returns UserSingleRespDto
   */
  public async getUser({
    userId,
    userIdType = "user_id",
    flatCustomData = false,
    withCustomData = false,
    withIdentities = false,
  }: {
    /** User ID **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Whether to flatten custom fields **/
    flatCustomData?: boolean;
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to get identities **/
    withIdentities?: boolean;
  }): Promise<UserSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user",
      params: {
        userId: userId,
        userIdType: userIdType,
        flatCustomData: flatCustomData,
        withCustomData: withCustomData,
        withIdentities: withIdentities,
      },
    });
  }

  /**
   * @summary Batch get user information
   * @description Batch get user information through user ID list, you can choose to get custom data, identities, and specify user ID type.
   * @returns UserListRespDto
   */
  public async getUserBatch({
    userIds,
    userIdType = "user_id",
    withCustomData = false,
    flatCustomData = false,
    withIdentities = false,
  }: {
    /** User ID array **/
    userIds: Array<string>;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to flatten custom fields **/
    flatCustomData?: boolean;
    /** Whether to get identities **/
    withIdentities?: boolean;
  }): Promise<UserListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-batch",
      params: {
        userIds: userIds,
        userIdType: userIdType,
        withCustomData: withCustomData,
        flatCustomData: flatCustomData,
        withIdentities: withIdentities,
      },
    });
  }

  /**
   * @summary User field decryption
   * @description The interface receives encrypted information and returns decrypted information
   * @returns UserFieldDecryptRespDto
   */
  public async userFieldDecrypt(
    requestBody: UserFieldDecryptReqDto
  ): Promise<UserFieldDecryptRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/users/field/decrypt",
      data: requestBody,
    });
  }

  /**
   * @summary Create user
   * @description Create user, email, phone number, username must contain one of them, email, phone number, username, externalId must be unique in the user pool, this interface will create user as administrator so no need for phone verification code and other security checks.
   * @returns UserSingleRespDto
   */
  public async createUser(
    requestBody: CreateUserReqDto
  ): Promise<UserSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-user",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create users
   * @description Batch create users, email, phone number, username must contain one of them, email, phone number, username, externalId must be unique in the user pool, this interface will create users as administrator so no need for phone verification code and other security checks.
   * @returns UserListRespDto
   */
  public async createUsersBatch(
    requestBody: CreateUserBatchReqDto
  ): Promise<UserListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-users-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Update user profile
   * @description Update user profile through user ID, email, phone number, username, externalId must be unique in the user pool, this interface will update user profile as administrator so no need for phone verification code and other security checks.
   * @returns UserSingleRespDto
   */
  public async updateUser(
    requestBody: UpdateUserReqDto
  ): Promise<UserSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-user",
      data: requestBody,
    });
  }

  /**
   * @summary Batch update user profile
   * @description Batch update user profile, email, phone number, username, externalId must be unique in the user pool, this interface will update user profile as administrator so no need for phone verification code and other security checks.
   * @returns UserListRespDto
   */
  public async updateUserBatch(
    requestBody: UpdateUserBatchReqDto
  ): Promise<UserListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-user-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete users
   * @description Delete users through user ID list, support batch deletion, can choose to specify user ID type.
   * @returns IsSuccessRespDto
   */
  public async deleteUsersBatch(
    requestBody: DeleteUsersBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-users-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get user's external identity sources
   * @description Get user's external identity sources through user ID, can choose to specify user ID type.
   * @returns IdentityListRespDto
   */
  public async getUserIdentities({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<IdentityListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-identities",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get user role list
   * @description Get user role list through user ID, can choose permission group code, specify user ID type etc. Note: If namespace is not passed, will only get roles under default permission group!
   * @returns RolePaginatedRespDto
   */
  public async getUserRoles({
    userId,
    userIdType = "user_id",
    namespace,
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Permission group (permission space) Code, get default permission group if not passed. **/
    namespace?: string;
  }): Promise<RolePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-roles",
      params: {
        userId: userId,
        userIdType: userIdType,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Get user real-name authentication information
   * @description Get user real-name authentication information through user ID, can choose to specify user ID type.
   * @returns PrincipalAuthenticationInfoPaginatedRespDto
   */
  public async getUserPrincipalAuthenticationInfo({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<PrincipalAuthenticationInfoPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-principal-authentication-info",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Delete user real-name authentication information
   * @description Delete user real-name authentication information through user ID, can choose to specify user ID type etc.
   * @returns IsSuccessRespDto
   */
  public async resetUserPrincipalAuthenticationInfo(
    requestBody: ResetUserPrincipalAuthenticationInfoDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/reset-user-principal-authentication-info",
      data: requestBody,
    });
  }

  /**
   * @summary Get user group list
   * @description Get user group list through user ID, can choose to specify user ID type etc.
   * @returns GroupPaginatedRespDto
   */
  public async getUserGroups({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<GroupPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-groups",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get user MFA binding information
   * @description Get user MFA binding information through user ID, can choose to specify user ID type etc.
   * @returns UserMfaSingleRespDto
   */
  public async getUserMfaInfo({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<UserMfaSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-mfa-info",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get archived user list
   * @description Get archived user list, support pagination, can filter start time etc.
   * @returns ListArchivedUsersSingleRespDto
   */
  public async listArchivedUsers({
    page = 1,
    limit = 10,
    startAt,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Start time, UNIX timestamp accurate to seconds, default not specified **/
    startAt?: number;
  }): Promise<ListArchivedUsersSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-archived-users",
      params: {
        page: page,
        limit: limit,
        startAt: startAt,
      },
    });
  }

  /**
   * @summary Force user logout
   * @description Force user logout through user ID, App ID list, can choose to specify user ID type etc.
   * @returns IsSuccessRespDto
   */
  public async kickUsers(requestBody: KickUsersDto): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/kick-users",
      data: requestBody,
    });
  }

  /**
   * @summary Check if user exists
   * @description Check if user exists based on conditions, can filter username, email, phone number, third-party external ID etc.
   * @returns IsUserExistsRespDto
   */
  public async isUserExists(
    requestBody: IsUserExistsReqDto
  ): Promise<IsUserExistsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/is-user-exists",
      data: requestBody,
    });
  }

  /**
   * @summary Get user accessible applications
   * @description Get user accessible applications through user ID, can choose to specify user ID type etc.
   * @returns AppListRespDto
   */
  public async getUserAccessibleApps({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<AppListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-accessible-apps",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get user authorized applications
   * @description Get user authorized applications through user ID, can choose to specify user ID type etc.
   * @returns AppListRespDto
   */
  public async getUserAuthorizedApps({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<AppListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-authorized-apps",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Check if user has certain role
   * @description Check if user has certain role through user ID, support passing multiple roles, can choose to specify user ID type etc.
   * @returns HasAnyRoleRespDto
   */
  public async hasAnyRole(
    requestBody: HasAnyRoleReqDto
  ): Promise<HasAnyRoleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/has-any-role",
      data: requestBody,
    });
  }

  /**
   * @summary Get user login history
   * @description Get user login history through user ID, support pagination, can choose to specify user ID type, application ID, start and end timestamp etc.
   * @returns UserLoginHistoryPaginatedRespDto
   */
  public async getUserLoginHistory({
    userId,
    userIdType = "user_id",
    appId,
    clientIp,
    start,
    end,
    page = 1,
    limit = 10,
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Application ID **/
    appId?: string;
    /** Client IP **/
    clientIp?: string;
    /** Start timestamp (milliseconds) **/
    start?: number;
    /** End timestamp (milliseconds) **/
    end?: number;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<UserLoginHistoryPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-login-history",
      params: {
        userId: userId,
        userIdType: userIdType,
        appId: appId,
        clientIp: clientIp,
        start: start,
        end: end,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Get applications that user has logged into
   * @description Get applications that user has logged into by user ID, you can specify user ID type.
   * @returns UserLoggedInAppsListRespDto
   */
  public async getUserLoggedinApps({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<UserLoggedInAppsListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-loggedin-apps",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get identity sources that user has logged into
   * @description Get identity sources that user has logged into by user ID, you can specify user ID type.
   * @returns UserLoggedInIdentitiesRespDto
   */
  public async getUserLoggedinIdentities({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<UserLoggedInIdentitiesRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-logged-in-identities",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get all authorized resources of user
   * @description Get all authorized resources of user by user ID, you can specify user ID type, etc. The authorized resources of user are the collection of resources granted to the user themselves, inherited through groups, inherited through roles, and inherited through organizations.
   * @returns AuthorizedResourcePaginatedRespDto
   */
  public async getUserAuthorizedResources({
    userId,
    userIdType = "user_id",
    namespace,
    resourceType,
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
    /** Resource type, such as data, API, menu, button **/
    resourceType?: "DATA" | "API" | "MENU" | "BUTTON" | "UI";
  }): Promise<AuthorizedResourcePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-authorized-resources",
      params: {
        userId: userId,
        userIdType: userIdType,
        namespace: namespace,
        resourceType: resourceType,
      },
    });
  }

  /**
   * @summary Check if user has session login status in application
   * @description Check if user has session login status in application
   * @returns CheckSessionStatusRespDto
   */
  public async checkSessionStatus(
    requestBody: CheckSessionStatusDto
  ): Promise<CheckSessionStatusRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-session-status",
      data: requestBody,
    });
  }

  /**
   * @summary Import user's OTP
   * @description Import user's OTP
   * @returns CommonResponseDto
   */
  public async importOtp(
    requestBody: ImportOtpReqDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/import-otp",
      data: requestBody,
    });
  }

  /**
   * @summary Get user's OTP binding secret
   * @description Get user's OTP binding secret by user ID. You can specify user ID type.
   * @returns GetOtpSecretRespDto
   */
  public async getOtpSecretByUser({
    userId,
    userIdType = "user_id",
  }: {
    /** User ID **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<GetOtpSecretRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-otp-secret-by-user",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get user's custom encrypted password
   * @description This function is mainly used to encrypt user's password after configuring RSA, SM2 and other encryption keys in the console.
   * @returns GetUserPasswordCiphertextRespDto
   */
  public async getUserPasswordCiphertext(
    requestBody: GetUserPasswordCiphertextDto
  ): Promise<GetUserPasswordCiphertextRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-user-password-ciphertext",
      data: requestBody,
    });
  }

  /**
   * @summary Bind an identity to user
   * @description User pool administrator manually binds identity information from external identity source to user. After binding, you can log in to the corresponding GenAuth user with the identity source that has performed the binding operation.
   * @returns LinkIdentityResDto
   */
  public async linkIdentity(
    requestBody: LinkIdentityDto
  ): Promise<LinkIdentityResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/link-identity",
      data: requestBody,
    });
  }

  /**
   * @summary Unbind all identity information of user under identity source
   * @description Unbind all identity information of user under an identity source. After unbinding, you will not be able to log in to the corresponding GenAuth user using the identity source that has performed the unbinding operation, unless you rebind the identity information.
   * @returns UnlinkIdentityResDto
   */
  public async unlinkIdentity(
    requestBody: UnlinkIdentity
  ): Promise<UnlinkIdentityResDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/unlink-identity",
      data: requestBody,
    });
  }

  /**
   * @summary Set user MFA status
   * @description Set user MFA status, i.e. MFA trigger data.
   * @returns IsSuccessRespDto
   */
  public async setUsersMfaStatus(
    requestBody: SetMfaStatusDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-mfa-status",
      data: requestBody,
    });
  }

  /**
   * @summary Get user MFA status
   * @description Get user MFA status, i.e. MFA trigger data.
   * @returns GetMapInfoRespDto
   */
  public async getUserMfaStatus({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<GetMapInfoRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-mfa-status",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Get user's third-party sync relationships
   * @description If users in GenAuth have performed upstream and downstream synchronization, this interface can be used to query associated user information in third parties
   * @returns SyncRelationListRespDto
   */
  public async getUserSyncRelations({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<SyncRelationListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-sync-relations",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Delete user sync relationship
   * @description If users in GenAuth have performed upstream and downstream synchronization, this interface can be used to delete the association relationship of a user under a specified identity source.
   * @returns IsSuccessRespDto
   */
  public async deleteUserSyncRelations(
    requestBody: DeleteUserSyncRelationReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-user-sync-relations",
      data: requestBody,
    });
  }

  /**
   * @summary Batch get user password ciphertext
   * @description Input user ID to get related user password ciphertext
   * @returns GetUserEncryptPasswordBatchRespDto
   */
  public async getUserEncryptPasswordBatch(
    requestBody: GetUserEncryptPasswordBatchDto
  ): Promise<GetUserEncryptPasswordBatchRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/batch-get-user-encrypt-password",
      data: requestBody,
    });
  }

  /**
   * @summary Get public account role list
   * @description Get user role list by user ID, you can select permission group code, specify user ID type, etc.
   * @returns PublicAccountPaginatedRespDto
   */
  public async getPublicAccountRoles({
    userId,
    userIdType = "user_id",
    namespace = "default",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
  }): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-roles-of-public-account",
      params: {
        userId: userId,
        userIdType: userIdType,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Get public account list of role
   * @description Get public account list of role by role ID.
   * @returns PublicAccountPaginatedRespDto
   */
  public async getPublicAccountsOfRole({
    roleId,
  }: {
    /** Role ID **/
    roleId: string;
  }): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-public-accounts-of-role",
      params: {
        roleId: roleId,
      },
    });
  }

  /**
   * @summary Bind batch roles to public account
   * @description Bind batch roles to public account
   * @returns IsSuccessRespDto
   */
  public async bindPublicAccountOfRoles(
    requestBody: SetUserRolesDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-public-account-of-roles",
      data: requestBody,
    });
  }

  /**
   * @summary Get public account list of group
   * @description Get public account list of group by group ID.
   * @returns PublicAccountPaginatedRespDto
   */
  public async getPublicAccountsOfGroup({
    groupId,
  }: {
    /** Group ID **/
    groupId: string;
  }): Promise<PublicAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-public-accounts-of-group",
      params: {
        groupId: groupId,
      },
    });
  }

  /**
   * @summary Get public account group list
   * @description Get public account group list by public account ID, you can specify user ID type, etc.
   * @returns GroupPaginatedRespDto
   */
  public async getGroupsOfPublicAccount({
    userId,
    userIdType = "user_id",
  }: {
    /** User's unique identifier, can be user ID, username, email, phone number, external ID, ID in external identity source. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<GroupPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-groups-of-public-account",
      params: {
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Add batch groups to public account
   * @description Add batch groups to public account by group ID
   * @returns IsSuccessRespDto
   */
  public async getPublicAccountOfGroups(
    requestBody: SetUserGroupsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-public-account-of-groups",
      data: requestBody,
    });
  }

  /**
   * @summary Get universal invitation configuration
   * @description Get universal invitation configuration.
   * @returns GetUniversalInvitationRespDto
   */
  public async getUniversalInvitation(): Promise<GetUniversalInvitationRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-universal-invitation-settings",
    });
  }

  /**
   * @summary Update universal invitation configuration
   * @description Update universal invitation configuration.
   * @returns GetUniversalInvitationRespDto
   */
  public async updateUniversalInvitation(
    requestBody: UpdateUniversalInvitationDto
  ): Promise<GetUniversalInvitationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-universal-invitation-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Generate universal invitation link
   * @description Generate universal invitation link.
   * @returns GenerateInvitationLinkRespDto
   */
  public async generateUniversalInvitation(): Promise<GenerateInvitationLinkRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/generate-universal-invitation-link",
    });
  }

  /**
   * @summary Query universal invitation application list
   * @description Query universal invitation application list.
   * @returns PaginationUniversalInvitationApplicantRespDto
   */
  public async filter(
    requestBody: PaginationUniversalInvitationApplicantQueryDto
  ): Promise<PaginationUniversalInvitationApplicantRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/filter-universal-invitation-applicants",
      data: requestBody,
    });
  }

  /**
   * @summary Batch approve universal invitation applications
   * @description Batch approve universal invitation applications.
   * @returns IsSuccessRespDto
   */
  public async approval(
    requestBody: ApprovalUniversalInvitationApplicantDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/batch-approval-universal-invitation-applicants",
      data: requestBody,
    });
  }

  /**
   * @summary Batch reject universal invitation applications
   * @description Batch reject universal invitation applications.
   * @returns IsSuccessRespDto
   */
  public async reject(
    requestBody: ApprovalUniversalInvitationApplicantDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/batch-reject-universal-invitation-applicant",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation policy list
   * @description Get invitation policy list, support pagination
   * @returns PaginationInvitationPolicyRespDto
   */
  public async listInvitationPolicies(
    requestBody: PaginationInvitationPolicyQueryDto
  ): Promise<PaginationInvitationPolicyRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-invitation-policies",
      data: requestBody,
    });
  }

  /**
   * @summary Create invitation policy
   * @description Create invitation policy
   * @returns GetInvitationPolicyRespDto
   */
  public async createInvitationPolicy(
    requestBody: CreateInvitationPolicyDto
  ): Promise<GetInvitationPolicyRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-invitation-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation policy details
   * @description Get invitation policy details
   * @returns GetInvitationPolicyRespDto
   */
  public async getPolicyDetailById({
    policyId,
    rosterId,
    withCreatorDetail = false,
  }: {
    /** Policy ID **/
    policyId: string;
    /** Roster ID, get associated policy details based on roster ID, when sending invitations in roster, a snapshot will be generated for the policy, if you need to get the corresponding policy configuration at the time of sending after sending invitations in roster, you should carry this parameter **/
    rosterId?: string;
    /** Whether to return creator details **/
    withCreatorDetail?: boolean;
  }): Promise<GetInvitationPolicyRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-invitation-policy",
      params: {
        policyId: policyId,
        rosterId: rosterId,
        withCreatorDetail: withCreatorDetail,
      },
    });
  }

  /**
   * @summary Create invitation policy copy
   * @description Create invitation policy copy
   * @returns GetInvitationPolicyRespDto
   */
  public async copyInvitationPolicyById(
    requestBody: CopyInvitationPolicyDto
  ): Promise<GetInvitationPolicyRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/copy-invitation-policy-by-id",
      data: requestBody,
    });
  }

  /**
   * @summary Update invitation policy
   * @description Update invitation policy
   * @returns GetInvitationPolicyRespDto
   */
  public async updateInvitationPolicy(
    requestBody: UpdateInvitationPolicyDto
  ): Promise<GetInvitationPolicyRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Get list of fields for policy process configuration supplementary information
   * @description Get list of fields for policy process configuration supplementary information
   * @returns GetExtendsFieldsRespDto
   */
  public async listRegisterExtendsFields({
    policyId,
    rosterId,
  }: {
    /** Policy ID **/
    policyId: string;
    /** Roster ID, get associated policy details based on roster ID, when sending invitations in roster, a snapshot will be generated for the policy, if you need to get the corresponding policy configuration at the time of sending after sending invitations in roster, you should carry this parameter **/
    rosterId?: string;
  }): Promise<GetExtendsFieldsRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-invitation-policy-extends-fields",
      params: {
        policyId: policyId,
        rosterId: rosterId,
      },
    });
  }

  /**
   * @summary Update policy process configuration supplementary information
   * @description Update policy process configuration supplementary information.
   * @returns GetExtendsFieldsRespDto
   */
  public async updateRegisterExtendsFields(
    requestBody: PolicyExtendsFieldsDto
  ): Promise<GetExtendsFieldsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-policy-extends-fields",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete invitation policies
   * @description Batch delete invitation policies
   * @returns IsSuccessRespDto
   */
  public async batchDeleteInvitationPolicies(
    requestBody: DeleteInvitationPolicyByIdsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-invitation-policies-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation policy user attribution details
   * @description Get invitation policy user attribution details
   * @returns UserAttributionSingleRespDto
   */
  public async getPolicyUserAttributionDetail({
    id,
    withTargetDetail,
  }: {
    /** Attribution association record ID **/
    id: string;
    /** Whether to return associated object details **/
    withTargetDetail?: boolean;
  }): Promise<UserAttributionSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-invitation-policy-user-attribution",
      params: {
        id: id,
        withTargetDetail: withTargetDetail,
      },
    });
  }

  /**
   * @summary Get invitation policy user attribution list
   * @description Get invitation policy user attribution list
   * @returns UserAttributionPaginationRespDto
   */
  public async listPolicyUserAttributionDetail({
    policyId,
    targetType,
    page = 1,
    limit = 10,
    withTargetDetail,
  }: {
    /** Policy ID **/
    policyId: string;
    /** Associated object type **/
    targetType: "department" | "post" | "role" | "group";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether to return associated object details **/
    withTargetDetail?: boolean;
  }): Promise<UserAttributionPaginationRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-invitation-policy-user-attributions",
      params: {
        page: page,
        limit: limit,
        policyId: policyId,
        withTargetDetail: withTargetDetail,
        targetType: targetType,
      },
    });
  }

  /**
   * @summary Add invitation policy user attribution
   * @description Add invitation policy user attribution
   * @returns UserAttributionSingleRespDto
   */
  public async addPolicyUserAttribution(
    requestBody: AddInvitationPolicyUserAttributionDto
  ): Promise<UserAttributionSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-invitation-policy-user-attribution",
      data: requestBody,
    });
  }

  /**
   * @summary Batch add invitation policy user attribution
   * @description Batch add invitation policy user attribution
   * @returns IsSuccessRespDto
   */
  public async addPolicyUserAttributionsBatch(
    requestBody: AddInvitationPolicyUserAttributionsBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-invitation-policy-user-attributions-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Delete invitation policy user attribution
   * @description Delete invitation policy user attribution
   * @returns IsSuccessRespDto
   */
  public async removePolicyUserAttribution(
    requestBody: RemoveInvitationPolicyUserAttributionDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/remove-invitation-policy-user-attribution",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete invitation policy user attribution
   * @description Batch delete invitation policy user attribution
   * @returns IsSuccessRespDto
   */
  public async removePolicyUserAttributionsBatch(
    requestBody: RemoveInvitationPolicyUserAttributionsBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/remove-invitation-policy-user-attributions-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation policy email template
   * @description Get invitation policy email template
   * @returns GetEmailTemplateRespDto
   */
  public async getInviteEmailTemplate(
    requestBody: EmailTemplateQueryDto
  ): Promise<GetEmailTemplateRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-invitation-policy-email-template",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation policy email template
   * @description Get invitation policy email template
   * @returns GetEmailTemplateRespDto
   */
  public async updateInviteEmailTemplate(
    requestBody: UpdateEmailTemplateDto
  ): Promise<GetEmailTemplateRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-policy-email-template",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation roster list
   * @description Get invitation roster list, supports pagination and search
   * @returns InvitationRosterPaginationRespDto
   */
  public async listInvitationRoster(
    requestBody: ListInvitationRosterDto
  ): Promise<InvitationRosterPaginationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-invitation-rosters",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation roster list by policy ID
   * @description Get invitation roster list by policy ID, supports pagination and search
   * @returns InvitationRosterPaginationRespDto
   */
  public async listInvitationRostersByPolicyId(
    requestBody: ListInvitationRosterByPolicyIdDto
  ): Promise<InvitationRosterPaginationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-invitation-rosters-by-policy-id",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation roster list not associated with policy
   * @description Get invitation roster list not associated with policy, supports pagination and search
   * @returns InvitationRosterPaginationRespDto
   */
  public async listInvitationRostersByNonPolicyId(
    requestBody: ListInvitationRosterDto
  ): Promise<InvitationRosterPaginationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-invitation-rosters-by-no-policy-id",
      data: requestBody,
    });
  }

  /**
   * @summary Get invitation roster details
   * @description Get invitation roster details by roster ID
   * @returns InvitationRosterSingleRespDto
   */
  public async getInvitationRoster({
    rosterId,
    withCreatorDetail = false,
    withUserCount = false,
    withAssignedPolicy = false,
  }: {
    /** Roster ID **/
    rosterId: string;
    /** Whether to return creator details **/
    withCreatorDetail?: boolean;
    /** Whether to return number of users associated with roster, optional **/
    withUserCount?: boolean;
    /** Whether to return policy associated with roster, optional **/
    withAssignedPolicy?: boolean;
  }): Promise<InvitationRosterSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-invitation-roster",
      params: {
        rosterId: rosterId,
        withCreatorDetail: withCreatorDetail,
        withUserCount: withUserCount,
        withAssignedPolicy: withAssignedPolicy,
      },
    });
  }

  /**
   * @summary Create invitation roster
   * @description Create invitation roster
   * @returns InvitationRosterSingleRespDto
   */
  public async createInvitationRoster(
    requestBody: CreateInvitationRosterDto
  ): Promise<InvitationRosterSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-invitation-roster",
      data: requestBody,
    });
  }

  /**
   * @summary Update invitation roster, batch associate invitation policies
   * @description Update invitation roster, batch associate invitation policies
   * @returns IsSuccessRespDto
   */
  public async batchBindPolicy(
    requestBody: BatchBindPolicy
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-roster-batch-bind-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Update invitation roster, batch disassociate by policy ID
   * @description Update invitation roster, batch disassociate by policy ID
   * @returns IsSuccessRespDto
   */
  public async batchUnbindPolicy(
    requestBody: BatchUnbindPolicy
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-roster-batch-unbind-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Update invitation roster
   * @description Update invitation roster
   * @returns InvitationRosterSingleRespDto
   */
  public async updateInvitationRoster(
    requestBody: UpdateInvitationRosterDto
  ): Promise<InvitationRosterSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-invitation-roster",
      data: requestBody,
    });
  }

  /**
   * @summary Delete invitation roster
   * @description Delete invitation roster
   * @returns IsSuccessRespDto
   */
  public async deleteInvitationRoster(
    requestBody: DeleteInvitationRosterDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-invitation-roster",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete invitation roster
   * @description Batch delete invitation roster
   * @returns IsSuccessRespDto
   */
  public async deleteInvitationRosterBatch(
    requestBody: DeleteInvitationRosterBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-invitation-rosters-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Send invitation by invitation roster
   * @description Send invitation by invitation roster
   * @returns IsSuccessRespDto
   */
  public async sendRosterInvitation(
    requestBody: SendRosterInvitationDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/send-roster-invitation",
      data: requestBody,
    });
  }

  /**
   * @summary Batch send invitations
   * @description Batch send invitations by invitee ID list
   * @returns IsSuccessRespDto
   */
  public async sendRosterInvitationBatch(
    requestBody: SendRosterInvitationBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/send-roster-invitation-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Revoke invitation
   * @description Revoke invitation by user ID
   * @returns IsSuccessRespDto
   */
  public async revertRosterInvitation(
    requestBody: RevertRosterInvitationDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revert-roster-invitation",
      data: requestBody,
    });
  }

  /**
   * @summary Revoke invitation
   * @description Batch revoke invitation by user ID
   * @returns IsSuccessRespDto
   */
  public async revertRosterInvitationBatch(
    requestBody: RevertRosterInvitationBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revert-roster-invitation-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Quick search invitee list
   * @description Quick search invitee list
   * @returns QuickFilterInviteePaginationRespDto
   */
  public async quickFilterInviteeList(
    requestBody: QuickFilterInvitationUserDto
  ): Promise<QuickFilterInviteePaginationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/quick-filter-invitees",
      data: requestBody,
    });
  }

  /**
   * @summary View invitees in roster
   * @description View invitees in roster
   * @returns InvitationUserPaginationRespDto
   */
  public async filterUsers(
    requestBody: ListInvitationUserDto
  ): Promise<InvitationUserPaginationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-invitation-invitees",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete invitees from roster
   * @description Batch delete invitees from roster
   * @returns IsSuccessRespDto
   */
  public async deleteInvitees(
    requestBody: DeleteRosterUsersDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/batch-delete-invitation-invitees",
      data: requestBody,
    });
  }

  /**
   * @summary Get template for importing roster invitees
   * @description Get template for importing roster invitees
   * @returns GetImportExportTemplateRespDto
   */
  public async importTemplate(): Promise<GetImportExportTemplateRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/invitation-invitee/template",
    });
  }

  /**
   * @summary Upload file for importing roster invitees
   * @description Upload file for importing roster invitees
   * @returns GetImportExportTemplateRespDto
   */
  public async upload(
    _private: boolean
  ): Promise<GetImportExportTemplateRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/invitation-invitee/upload",
      params: {
        private: _private,
      },
    });
  }

  /**
   * @summary Import roster invitees
   * @description Import roster invitees
   * @returns GetImportInviteeRespDto
   */
  public async importUsers(
    requestBody: ImportUsersDto
  ): Promise<GetImportInviteeRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/invitation-invitee/import",
      data: requestBody,
    });
  }

  /**
   * @summary Export roster invitees
   * @description Export roster invitees
   * @returns GetImportExportTemplateRespDto
   */
  public async exportUsers(
    requestBody: ExportUsersDto
  ): Promise<GetImportExportTemplateRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/invitation-invitee/export",
      data: requestBody,
    });
  }

  /**
   * @summary Get group details
   * @description Get group details by group code.
   * @returns GroupSingleRespDto
   */
  public async getGroup({
    code,
    withCustomData,
  }: {
    /** Group code **/
    code: string;
    /** Whether to get custom data **/
    withCustomData?: boolean;
  }): Promise<GroupSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-group",
      params: {
        code: code,
        withCustomData: withCustomData,
      },
    });
  }

  /**
   * @summary Get group list
   * @description Get group list, supports pagination.
   * @returns GroupPaginatedRespDto
   */
  public async listGroups({
    keywords,
    page = 1,
    limit = 10,
    withMetadata,
    withCustomData,
    flatCustomData = false,
  }: {
    /** Search group code or group name **/
    keywords?: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether to show metadata content **/
    withMetadata?: boolean;
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to flatten extended fields **/
    flatCustomData?: boolean;
  }): Promise<GroupPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-groups",
      params: {
        keywords: keywords,
        page: page,
        limit: limit,
        withMetadata: withMetadata,
        withCustomData: withCustomData,
        flatCustomData: flatCustomData,
      },
    });
  }

  /**
   * @summary Get all groups
   * @description Get all groups
   * @returns GroupListRespDto
   */
  public async getAllGroups({
    fetchMembers = false,
    withCustomData,
  }: {
    /** Whether to get member list **/
    fetchMembers?: boolean;
    /** Whether to get custom data **/
    withCustomData?: boolean;
  }): Promise<GroupListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-all-groups",
      params: {
        fetchMembers: fetchMembers,
        withCustomData: withCustomData,
      },
    });
  }

  /**
   * @summary Create group
   * @description Create group, a group must include a group name and unique identifier code, and must be a valid English identifier, such as developers.
   * @returns GroupSingleRespDto
   */
  public async createGroup(
    requestBody: CreateGroupReqDto
  ): Promise<GroupSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-group",
      data: requestBody,
    });
  }

  /**
   * @summary Create or update group
   * @description Create if not exists, update if exists.
   * @returns CreateOrUpdateGroupRespDto
   */
  public async createOrUpdateGroup(
    requestBody: CreateOrUpdateGroupReqDto
  ): Promise<CreateOrUpdateGroupRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-or-update-group",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create groups
   * @description Batch create groups, a group must include a group name and unique identifier code, and must be a valid English identifier, such as developers.
   * @returns GroupListRespDto
   */
  public async createGroupsBatch(
    requestBody: CreateGroupBatchReqDto
  ): Promise<GroupListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-groups-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Update group
   * @description Update group by group code, can modify the code of this group.
   * @returns GroupSingleRespDto
   */
  public async updateGroup(
    requestBody: UpdateGroupReqDto
  ): Promise<GroupSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-group",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete groups
   * @description Batch delete groups by group code.
   * @returns IsSuccessRespDto
   */
  public async deleteGroupsBatch(
    requestBody: DeleteGroupsReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-groups-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Add group members
   * @description Add group members, members are passed as user ID array.
   * @returns IsSuccessRespDto
   */
  public async addGroupMembers(
    requestBody: AddGroupMembersReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-group-members",
      data: requestBody,
    });
  }

  /**
   * @summary Batch remove group members
   * @description Batch remove group members, members are passed as user ID array.
   * @returns IsSuccessRespDto
   */
  public async removeGroupMembers(
    requestBody: RemoveGroupMembersReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/remove-group-members",
      data: requestBody,
    });
  }

  /**
   * @summary Get group member list
   * @description Get group member list by group code, supports pagination, can get custom data, identities, ID list.
   * @returns UserPaginatedRespDto
   */
  public async listGroupMembers({
    code,
    page = 1,
    limit = 10,
    withCustomData = false,
    withIdentities = false,
    flatCustomData = false,
  }: {
    /** Group code **/
    code: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to get identities **/
    withIdentities?: boolean;
    /** Whether to flatten extended fields **/
    flatCustomData?: boolean;
  }): Promise<UserPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-group-members",
      params: {
        code: code,
        page: page,
        limit: limit,
        withCustomData: withCustomData,
        withIdentities: withIdentities,
        flatCustomData: flatCustomData,
      },
    });
  }

  /**
   * @summary Get list of authorized resources for group
   * @description Get list of authorized resources for group by group code, can filter by resource type and permission group code.
   * @returns AuthorizedResourceListRespDto
   */
  public async getGroupAuthorizedResources({
    code,
    namespace,
    resourceType,
  }: {
    /** Group code **/
    code: string;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
    /** Resource type **/
    resourceType?: "DATA" | "API" | "MENU" | "BUTTON" | "UI";
  }): Promise<AuthorizedResourceListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-group-authorized-resources",
      params: {
        code: code,
        namespace: namespace,
        resourceType: resourceType,
      },
    });
  }

  /**
   * @summary Get role details
   * @description Get role details by role code within permission group.
   * @returns RoleSingleRespDto
   */
  public async getRole({
    code,
    namespace,
  }: {
    /** Unique identifier of role within permission group **/
    code: string;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
  }): Promise<RoleSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-role",
      params: {
        code: code,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Assign role to single target
   * @description Assign role to target by role code within permission group, target can be user.
   * @returns IsSuccessRespDto
   */
  public async assignRole(
    requestBody: AssignRoleDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/assign-role",
      data: requestBody,
    });
  }

  /**
   * @summary Batch assign roles
   * @description Batch assign roles, targets can be users
   * @returns IsSuccessRespDto
   */
  public async assignRoleBatch(
    requestBody: AssignRoleBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/assign-role-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Revoke assigned role
   * @description Revoke assigned role by role code within permission group, target can be user
   * @returns IsSuccessRespDto
   */
  public async revokeRole(
    requestBody: RevokeRoleDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revoke-role",
      data: requestBody,
    });
  }

  /**
   * @summary Batch revoke assigned roles
   * @description Batch revoke assigned roles, targets can be users
   * @returns IsSuccessRespDto
   */
  public async revokeRoleBatch(
    requestBody: RevokeRoleBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revoke-role-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get list of authorized resources for role
   * @description Get list of authorized resources for role by role code within permission group.
   * @returns RoleAuthorizedResourcePaginatedRespDto
   */
  public async getRoleAuthorizedResources({
    code,
    namespace,
    resourceType,
  }: {
    /** Unique identifier of role within permission group **/
    code: string;
    /** Code of permission group **/
    namespace?: string;
    /** Resource type, such as data, API, button, menu **/
    resourceType?: "DATA" | "API" | "MENU" | "BUTTON" | "UI";
  }): Promise<RoleAuthorizedResourcePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-role-authorized-resources",
      params: {
        code: code,
        namespace: namespace,
        resourceType: resourceType,
      },
    });
  }

  /**
   * @summary Get role members list
   * @description Get role members list by role code within permission group, supports pagination, can choose to get custom data, identities etc.
   * @returns UserPaginatedRespDto
   */
  public async listRoleMembers({
    code,
    page = 1,
    limit = 10,
    withCustomData = false,
    withIdentities = false,
    namespace,
  }: {
    /** Unique identifier of role within permission group **/
    code: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether to get custom data **/
    withCustomData?: boolean;
    /** Whether to get identities **/
    withIdentities?: boolean;
    /** Code of permission group **/
    namespace?: string;
  }): Promise<UserPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-role-members",
      params: {
        page: page,
        limit: limit,
        withCustomData: withCustomData,
        withIdentities: withIdentities,
        code: code,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Create role
   * @description Create role by role code within permission group (permission space), can set role description, role name etc.
   * @returns RoleSingleRespDto
   */
  public async createRole(
    requestBody: CreateRoleDto
  ): Promise<RoleSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-role",
      data: requestBody,
    });
  }

  /**
   * @summary Get role list
   * @description Get role list, supports pagination, supports filtering by permission group (permission space)
   * @returns RolePaginatedRespDto
   */
  public async listRoles({
    page = 1,
    limit = 10,
    keywords,
    namespace = "default",
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Used for fuzzy search by role code or name, optional. **/
    keywords?: string;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
  }): Promise<RolePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-roles",
      params: {
        page: page,
        limit: limit,
        keywords: keywords,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Delete roles within single permission group (permission space)
   * @description Delete roles within single permission group (permission space), supports batch deletion.
   * @returns IsSuccessRespDto
   */
  public async deleteRolesBatch(
    requestBody: DeleteRoleDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-roles-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create roles
   * @description Batch create roles, can set permission group, role description etc.
   * @returns IsSuccessRespDto
   */
  public async createRolesBatch(
    requestBody: CreateRolesBatch
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-roles-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Update role
   * @description Update role by old and new role code within permission group (permission space), can set role name, role description etc.
   * @returns IsSuccessRespDto
   */
  public async updateRole(
    requestBody: UpdateRoleDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-role",
      data: requestBody,
    });
  }

  /**
   * @summary Delete roles across permission groups (spaces)
   * @description Delete roles across permission groups (spaces), supports batch deletion.
   * @returns IsSuccessRespDto
   */
  public async deleteRoles(
    requestBody: DeleteRoleBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/multiple-namespace-delete-roles-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Check if role code or name is available
   * @description Check if role code or name is available by user pool ID, permission space code and role code, or user pool ID, permission space name and role name.
   * @returns RoleCheckParamsRespDto
   */
  public async checkParamsNamespace(
    requestBody: CheckRoleParamsDto
  ): Promise<RoleCheckParamsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-role-params",
      data: requestBody,
    });
  }

  /**
   * @summary Get role authorization list
   * @description Get role authorization list.
   * @returns RoleListPageRespDto
   */
  public async listRoleAssignments({
    roleCode,
    page = 1,
    limit = 10,
    query,
    namespaceCode,
    targetType,
  }: {
    /** Role code, can only use letters, numbers and -_, maximum 50 characters **/
    roleCode: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Search by role code or role name **/
    query?: string;
    /** Permission space code **/
    namespaceCode?: string;
    /** Target type, accepts user **/
    targetType?: Array<"USER">;
  }): Promise<RoleListPageRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-role-assignments",
      params: {
        page: page,
        limit: limit,
        query: query,
        roleCode: roleCode,
        namespaceCode: namespaceCode,
        targetType: targetType,
      },
    });
  }

  /**
   * @summary Create admin role
   * @description Create admin role by role code, role name, can set role description
   * @returns RoleCheckParamsRespDto
   */
  public async createAdminRole(
    requestBody: CreateAdminRoleDto
  ): Promise<RoleCheckParamsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-admin-role",
      data: requestBody,
    });
  }

  /**
   * @summary Delete custom admin roles
   * @description Delete custom admin roles, supports batch deletion.
   * @returns IsSuccessRespDto
   */
  public async deleteAdminRolesBatch(
    requestBody: DeleteAdminRoleDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-admin-roles",
      data: requestBody,
    });
  }

  /**
   * @summary Check role mutual exclusion
   * @description Check if a group of roles have mutual exclusion relationship
   * @returns CheckRoleMutualExclusionRespDto
   */
  public async checkMutualExclusion(
    requestBody: CheckRoleMutualExclusionReqDto
  ): Promise<CheckRoleMutualExclusionRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-role-mutual-exclusion",
      data: requestBody,
    });
  }

  /**
   * @summary Get identity source list
   * @description Get identity source list
   * @returns ExtIdpListPaginatedRespDto
   */
  public async listExtIdp({
    appId,
  }: {
    /** Application ID **/
    appId?: string;
  }): Promise<ExtIdpListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-ext-idp",
      params: {
        appId: appId,
      },
    });
  }

  /**
   * @summary Get identity source details
   * @description Get identity source details by identity source ID
   * @returns ExtIdpDetailSingleRespDto
   */
  public async getExtIdp({
    id,
    appId,
    type,
  }: {
    /** Identity source ID **/
    id: string;
    /** Application ID **/
    appId?: string;
    /** Identity source type **/
    type?: "social" | "enterprise";
  }): Promise<ExtIdpDetailSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-ext-idp",
      params: {
        appId: appId,
        id: id,
        type: type,
      },
    });
  }

  /**
   * @summary Create identity source
   * @description Create identity source, can set identity source name, connection type
   * @returns ExtIdpSingleRespDto
   */
  public async createExtIdp(
    requestBody: CreateExtIdpDto
  ): Promise<ExtIdpSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-ext-idp",
      data: requestBody,
    });
  }

  /**
   * @summary Update identity source configuration
   * @description Update identity source configuration, can set identity source ID and name.
   * @returns ExtIdpSingleRespDto
   */
  public async updateExtIdp(
    requestBody: UpdateExtIdpDto
  ): Promise<ExtIdpSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-ext-idp",
      data: requestBody,
    });
  }

  /**
   * @summary Delete identity source
   * @description Delete identity source by identity source ID.
   * @returns IsSuccessRespDto
   */
  public async deleteExtIdp(
    requestBody: DeleteExtIdpDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-ext-idp",
      data: requestBody,
    });
  }

  /**
   * @summary Create new connection under existing identity source
   * @description Create new connection under existing identity source, can set identity source icon, login-only support etc.
   * @returns ExtIdpConnDetailSingleRespDto
   */
  public async createExtIdpConn(
    requestBody: CreateExtIdpConnDto
  ): Promise<ExtIdpConnDetailSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-ext-idp-conn",
      data: requestBody,
    });
  }

  /**
   * @summary Update identity source connection
   * @description Update identity source connection, can set identity source icon, login-only support etc.
   * @returns ExtIdpConnDetailSingleRespDto
   */
  public async updateExtIdpConn(
    requestBody: UpdateExtIdpConnDto
  ): Promise<ExtIdpConnDetailSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-ext-idp-conn",
      data: requestBody,
    });
  }

  /**
   * @summary Delete identity source connection
   * @description Delete identity source connection by identity source connection ID.
   * @returns IsSuccessRespDto
   */
  public async deleteExtIdpConn(
    requestBody: DeleteExtIdpConnDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-ext-idp-conn",
      data: requestBody,
    });
  }

  /**
   * @summary Identity source connection switch
   * @description Identity source connection switch, can turn on or off identity source connection.
   * @returns IsSuccessRespDto
   */
  public async changeExtIdpConnState(
    requestBody: ChangeExtIdpConnStateDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/change-ext-idp-conn-state",
      data: requestBody,
    });
  }

  /**
   * @summary Application connection details under identity source
   * @description Get application connection status in identity source details page
   * @returns ExtIdpListPaginatedRespDto
   */
  public async extIdpConnStateByApps({
    id,
    appId,
    type,
  }: {
    /** Identity source ID **/
    id: string;
    /** Application ID **/
    appId?: string;
    /** Identity source type **/
    type?: "social" | "enterprise";
  }): Promise<ExtIdpListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/ext-idp-conn-apps",
      params: {
        appId: appId,
        id: id,
        type: type,
      },
    });
  }

  /**
   * @summary Get WeChat Mini Program, Official Account Access Token
   * @description Get WeChat Mini Program, Official Account Access Token cached by GenAuth server
   * @returns GetWechatAccessTokenInfoRespDto
   */
  public async getWechatMpAccessTokenInfo(
    requestBody: GetWechatAccessTokenDto
  ): Promise<GetWechatAccessTokenInfoRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-weixin-access-token",
      data: requestBody,
    });
  }

  /**
   * @summary Get user built-in field list
   * @description Get user built-in field list
   * @returns CustomFieldListRespDto
   */
  public async getUserBaseFields(): Promise<CustomFieldListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-user-base-fields",
    });
  }

  /**
   * @summary Get user built-in field list
   * @description Get user built-in field list
   * @returns ListCistomFieldsResDto
   */
  public async listUserBaseFields({
    targetType,
    dataType,
    page = 1,
    limit = 10,
    userVisible,
    adminVisible,
    accessControl,
    keyword,
    lang,
  }: {
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     * ;This interface does not support group(GROUP) yet **/
    targetType: "USER" | "ROLE" | "GROUP";
    /** Field type **/
    dataType:
      | "STRING"
      | "NUMBER"
      | "DATETIME"
      | "BOOLEAN"
      | "OBJECT"
      | "SELECT";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** User visible **/
    userVisible?: boolean;
    /** Admin visible **/
    adminVisible?: boolean;
    /** Access control **/
    accessControl?: boolean;
    /** Search keyword **/
    keyword?: string;
    /** Search language **/
    lang?: string;
  }): Promise<ListCistomFieldsResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-user-base-fields",
      params: {
        targetType: targetType,
        dataType: dataType,
        page: page,
        limit: limit,
        userVisible: userVisible,
        adminVisible: adminVisible,
        accessControl: accessControl,
        keyword: keyword,
        lang: lang,
      },
    });
  }

  /**
   * @summary Modify user built-in field configuration
   * @description Modify user built-in field configuration, built-in fields do not allow modifying data type, uniqueness.
   * @returns CustomFieldListRespDto
   */
  public async setUserBaseFields(
    requestBody: SetUserBaseFieldsReqDto
  ): Promise<CustomFieldListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-user-base-fields",
      data: requestBody,
    });
  }

  /**
   * @summary Get custom field list
   * @description Get custom field list for user or role by target type.
   * @returns CustomFieldListRespDto
   */
  public async getCustomFields({
    targetType,
  }: {
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     * ;This interface does not support group(GROUP) yet **/
    targetType: "USER" | "ROLE" | "GROUP";
  }): Promise<CustomFieldListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-custom-fields",
      params: {
        targetType: targetType,
      },
    });
  }

  /**
   * @summary Get custom field list
   * @description Get custom field list for user, role by target type.
   * @returns ListCistomFieldsResDto
   */
  public async listCustFields({
    targetType,
    dataType,
    page = 1,
    limit = 10,
    userVisible,
    adminVisible,
    accessControl,
    keyword,
    lang,
  }: {
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     * ;This interface does not support group(GROUP) yet **/
    targetType: "USER" | "ROLE" | "GROUP";
    /** Field type **/
    dataType:
      | "STRING"
      | "NUMBER"
      | "DATETIME"
      | "BOOLEAN"
      | "OBJECT"
      | "SELECT";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** User visible **/
    userVisible?: boolean;
    /** Admin visible **/
    adminVisible?: boolean;
    /** Access control **/
    accessControl?: boolean;
    /** Search keyword **/
    keyword?: string;
    /** Search language **/
    lang?: string;
  }): Promise<ListCistomFieldsResDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-custom-fields",
      params: {
        targetType: targetType,
        dataType: dataType,
        page: page,
        limit: limit,
        userVisible: userVisible,
        adminVisible: adminVisible,
        accessControl: accessControl,
        keyword: keyword,
        lang: lang,
      },
    });
  }

  /**
   * @summary Create/modify custom field definition
   * @description Create/modify user, role custom field definition, if input key does not exist then create, if exists then update.
   * @returns CustomFieldListRespDto
   */
  public async setCustomFields(
    requestBody: SetCustomFieldsReqDto
  ): Promise<CustomFieldListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-custom-fields",
      data: requestBody,
    });
  }

  /**
   * @summary Delete custom field definition
   * @description Delete user, role custom field definition.
   * @returns IsSuccessRespDto
   */
  public async deleteCustomFields(
    requestBody: DeleteCustomFieldsReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-custom-fields",
      data: requestBody,
    });
  }

  /**
   * @summary Set custom field value
   * @description Set custom field value for user, role, if exists then update, if not exist then create.
   * @returns IsSuccessRespDto
   */
  public async setCustomData(
    requestBody: SetCustomDataReqDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/set-custom-data",
      data: requestBody,
    });
  }

  /**
   * @summary Get custom field values for user, group, role, organization
   * @description Get custom field values for user, group, role, organization by filter conditions.
   * @returns GetCustomDataRespDto
   */
  public async getCustomData({
    targetType,
    targetIdentifier,
    namespace,
  }: {
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     *  **/
    targetType: "USER" | "ROLE" | "GROUP";
    /** Unique identifier of target object:
     * - For user, it's user ID, like `6343b98b7cfxxx9366e9b7c`
     * - For role, it's role code, like `admin`
     * - For group, it's group code, like `developer`
     *  **/
    targetIdentifier: string;
    /** Code of permission group, required when targetType is role, otherwise can be ignored **/
    namespace?: string;
  }): Promise<GetCustomDataRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-custom-data",
      params: {
        targetType: targetType,
        targetIdentifier: targetIdentifier,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Create resource
   * @description Create resource, can set resource description, defined operation types, URL identifier etc.
   * @returns ResourceRespDto
   */
  public async createResource(
    requestBody: CreateResourceDto
  ): Promise<ResourceRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create resources
   * @description Batch create resources, can set resource description, defined operation types, URL identifier etc.
   * @returns IsSuccessRespDto
   */
  public async createResourcesBatch(
    requestBody: CreateResourcesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-resources-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get resource details
   * @description Get resource details by filter conditions.
   * @returns ResourceRespDto
   */
  public async getResource({
    code,
    namespace,
  }: {
    /** Resource unique identifier **/
    code: string;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
  }): Promise<ResourceRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-resource",
      params: {
        code: code,
        namespace: namespace,
      },
    });
  }

  /**
   * @summary Batch get resource details
   * @description Batch get resource details by filter conditions.
   * @returns ResourceListRespDto
   */
  public async getResourcesBatch({
    codeList,
    namespace,
  }: {
    /** Resource code list, can use comma to separate for batch **/
    codeList: Array<string>;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
  }): Promise<ResourceListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-resources-batch",
      params: {
        namespace: namespace,
        codeList: codeList,
      },
    });
  }

  /**
   * @summary Get paginated common resource list
   * @description Get paginated common resource details list by filter conditions.
   * @returns CommonResourcePaginatedRespDto
   */
  public async listCommonResource({
    page = 1,
    limit = 10,
    keyword,
    namespaceCodeList,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Query condition **/
    keyword?: string;
    /** Permission space list **/
    namespaceCodeList?: string;
  }): Promise<CommonResourcePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-common-resource",
      params: {
        page: page,
        limit: limit,
        keyword: keyword,
        namespaceCodeList: namespaceCodeList,
      },
    });
  }

  /**
   * @summary Get paginated resource list
   * @description Get paginated resource details list by filter conditions.
   * @returns ResourcePaginatedRespDto
   */
  public async listResources({
    namespace,
    type,
    page = 1,
    limit = 10,
  }: {
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
    /** Resource type **/
    type?: "DATA" | "API" | "MENU" | "BUTTON" | "UI";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<ResourcePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-resources",
      params: {
        namespace: namespace,
        type: type,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Update resource
   * @description Update resource, can set resource description, operation type, URL identifier, etc.
   * @returns ResourceRespDto
   */
  public async updateResource(
    requestBody: UpdateResourceDto
  ): Promise<ResourceRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Delete resource
   * @description Delete resource by resource unique identifier and permission group.
   * @returns IsSuccessRespDto
   */
  public async deleteResource(
    requestBody: DeleteResourceDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete resources
   * @description Batch delete resources by resource unique identifier and permission group
   * @returns IsSuccessRespDto
   */
  public async deleteResourcesBatch(
    requestBody: DeleteResourcesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-resources-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete resources
   * @description Batch delete resources by resource id
   * @returns IsSuccessRespDto
   */
  public async batchDeleteCommonResource(
    requestBody: DeleteCommonResourcesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-common-resources-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Create permission group
   * @description Create permission group, can set permission group name, Code and description.
   * @returns NamespaceRespDto
   */
  public async createNamespace(
    requestBody: CreateNamespaceDto
  ): Promise<NamespaceRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create permission groups
   * @description Batch create permission groups, can set permission group name, Code and description separately.
   * @returns IsSuccessRespDto
   */
  public async createNamespacesBatch(
    requestBody: CreateNamespacesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-namespaces-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get permission group details
   * @description Get permission group details by permission group unique identifier (Code).
   * @returns NamespaceRespDto
   */
  public async getNamespace({
    code,
  }: {
    /** Permission group unique identifier **/
    code: string;
  }): Promise<NamespaceRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-namespace",
      params: {
        code: code,
      },
    });
  }

  /**
   * @summary Batch get permission group details
   * @description Batch get permission group details by permission group unique identifier (Code).
   * @returns NamespaceListRespDto
   */
  public async getNamespacesBatch({
    codeList,
  }: {
    /** Permission group code list, can use comma to separate for batch **/
    codeList: Array<string>;
  }): Promise<NamespaceListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-namespaces-batch",
      params: {
        codeList: codeList,
      },
    });
  }

  /**
   * @summary Update permission group information
   * @description Update permission group information, can modify name, description and new unique identifier (NewCode).
   * @returns UpdateNamespaceRespDto
   */
  public async updateNamespace(
    requestBody: UpdateNamespaceDto
  ): Promise<UpdateNamespaceRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Delete permission group information
   * @description Delete permission group information by permission group unique identifier (Code).
   * @returns IsSuccessRespDto
   */
  public async deleteNamespace(
    requestBody: DeleteNamespaceDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete permission groups
   * @description Batch delete permission groups by permission group unique identifier (Code).
   * @returns IsSuccessRespDto
   */
  public async deleteNamespacesBatch(
    requestBody: DeleteNamespacesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-namespaces-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get paginated permission group list
   * @description Get paginated permission group list by filter conditions.
   * @returns NamespaceListPaginatedRespDto
   */
  public async listNamespaces({
    page = 1,
    limit = 10,
    keywords,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Search permission group Code **/
    keywords?: string;
  }): Promise<NamespaceListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-namespaces",
      params: {
        page: page,
        limit: limit,
        keywords: keywords,
      },
    });
  }

  /**
   * @summary Get paginated role list under permission group
   * @description Get paginated role list under permission group by filter conditions.
   * @returns NamespaceRolesListPaginatedRespDto
   */
  public async listNamespaceRoles({
    code,
    page = 1,
    limit = 10,
    keywords,
  }: {
    /** Permission group unique identifier **/
    code: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Role Code or name **/
    keywords?: string;
  }): Promise<NamespaceRolesListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-namespace-roles",
      params: {
        page: page,
        limit: limit,
        code: code,
        keywords: keywords,
      },
    });
  }

  /**
   * @summary Authorize resources
   * @description Authorize one/multiple resources to subjects like users, roles, groups, organizations, etc., and can specify different operation permissions separately.
   * @returns IsSuccessRespDto
   */
  public async authorizeResources(
    requestBody: AuthorizeResourcesDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/authorize-resources",
      data: requestBody,
    });
  }

  /**
   * @summary Get authorized resource list for a subject
   * @description Get authorized resource list for a subject by filter conditions.
   * @returns AuthorizedResourcePaginatedRespDto
   */
  public async getAuthorizedResources({
    targetType,
    targetIdentifier,
    namespace,
    resourceType,
    resourceList,
    withDenied = false,
  }: {
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     *  **/
    targetType: "USER" | "ROLE" | "GROUP";
    /** Target object unique identifier:
     * - For user, it's user ID, like `6343b98b7cfxxx9366e9b7c`
     * - For role, it's role code, like `admin`
     * - For group, it's group code, like `developer`
     *  **/
    targetIdentifier: string;
    /** Code of permission group (permission space), get default permission group if not provided. **/
    namespace?: string;
    /** Limit resource type, like data, API, button, menu **/
    resourceType?: "DATA" | "API" | "MENU" | "BUTTON" | "UI";
    /** Limit query resource list, if specified, will only return specified resource list.
     *
     * resourceList parameter supports prefix matching, for example:
     * - If authorized a resource as `books:123`, can match with `books:*`;
     * - If authorized a resource as `books:fictions_123`, can match with `books:fictions_`;
     *  **/
    resourceList?: Array<string>;
    /** Whether to get denied resources **/
    withDenied?: boolean;
  }): Promise<AuthorizedResourcePaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-authorized-resources",
      params: {
        targetType: targetType,
        targetIdentifier: targetIdentifier,
        namespace: namespace,
        resourceType: resourceType,
        resourceList: resourceList,
        withDenied: withDenied,
      },
    });
  }

  /**
   * @summary Check if user has permission for an operation on a resource
   * @description Check if user has permission for an operation on a resource.
   * @returns IsActionAllowedRespDtp
   */
  public async isActionAllowed(
    requestBody: IsActionAllowedDto
  ): Promise<IsActionAllowedRespDtp> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/is-action-allowed",
      data: requestBody,
    });
  }

  /**
   * @summary Get authorized subjects for a resource
   * @description Get authorized subjects for a resource
   * @returns GetResourceAuthorizedTargetRespDto
   */
  public async getResourceAuthorizedTargets(
    requestBody: GetResourceAuthorizedTargetsDto
  ): Promise<GetResourceAuthorizedTargetRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-resource-authorized-targets",
      data: requestBody,
    });
  }

  /**
   * @summary Get user action logs
   * @description Get user action logs by request ID, client IP, user ID, application ID, start timestamp, request success status, pagination parameters
   * @returns UserActionLogRespDto
   */
  public async getUserActionLogs(
    requestBody: GetUserActionLogsDto
  ): Promise<UserActionLogRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-user-action-logs",
      data: requestBody,
    });
  }

  /**
   * @summary Get admin audit logs
   * @description Get admin audit logs by request ID, client IP, operation type, resource type, admin user ID, request success status, start timestamp, end timestamp, pagination
   * @returns AdminAuditLogRespDto
   */
  public async getAdminAuditLogs(
    requestBody: GetAdminAuditLogsDto
  ): Promise<AdminAuditLogRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-admin-audit-logs",
      data: requestBody,
    });
  }

  /**
   * @summary Get email template list
   * @description Get email template list
   * @returns GetEmailTemplatesRespDto
   */
  public async getEmailTemplates(): Promise<GetEmailTemplatesRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-email-templates",
    });
  }

  /**
   * @summary Update email template
   * @description Update email template
   * @returns EmailTemplateSingleItemRespDto
   */
  public async updateEmailTemplate(
    requestBody: UpdateEmailTemplateDto
  ): Promise<EmailTemplateSingleItemRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-email-template",
      data: requestBody,
    });
  }

  /**
   * @summary Preview email template
   * @description Preview email template
   * @returns PreviewEmailTemplateRespDto
   */
  public async previewEmailTemplate(
    requestBody: PreviewEmailTemplateDto
  ): Promise<PreviewEmailTemplateRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/preview-email-template",
      data: requestBody,
    });
  }

  /**
   * @summary Get third-party email service configuration
   * @description Get third-party email service configuration
   * @returns EmailProviderRespDto
   */
  public async getEmailProvider(): Promise<EmailProviderRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-email-provider",
    });
  }

  /**
   * @summary Configure third-party email service
   * @description Configure third-party email service
   * @returns EmailProviderRespDto
   */
  public async configEmailProvider(
    requestBody: ConfigEmailProviderDto
  ): Promise<EmailProviderRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/config-email-provider",
      data: requestBody,
    });
  }

  /**
   * @summary Get application details
   * @description Get application details by application ID.
   * @returns ApplicationSingleRespDto
   */
  public async getApplication({
    appId,
  }: {
    /** Application ID **/
    appId: string;
  }): Promise<ApplicationSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-application",
      params: {
        appId: appId,
      },
    });
  }

  /**
   * @summary Subject authorization details
   * @description Subject authorization details
   * @returns GetSubjectAuthRespDto
   */
  public async detailAuthSubject({
    targetId,
    targetType,
    appId,
  }: {
    /** Subject ID **/
    targetId: string;
    /** Subject type **/
    targetType: "USER" | "ROLE" | "GROUP" | "ORG" | "AK_SK";
    /** Application ID **/
    appId: string;
  }): Promise<GetSubjectAuthRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-subject-auth-detail",
      params: {
        targetId: targetId,
        targetType: targetType,
        appId: appId,
      },
    });
  }

  /**
   * @summary Subject authorization list
   * @description Subject authorization list
   * @returns ListApplicationSubjectRespDto
   */
  public async listAuthSubject(
    requestBody: ListAuthSubjectDto
  ): Promise<ListApplicationSubjectRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-subject-auth",
      data: requestBody,
    });
  }

  /**
   * @summary Application authorization list
   * @description Application authorization list
   * @returns ListApplicationAuthPaginatedRespDto
   */
  public async listAuthApplication(
    requestBody: ListApplicationAuthDto
  ): Promise<ListApplicationAuthPaginatedRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-applications-auth",
      data: requestBody,
    });
  }

  /**
   * @summary Update authorization switch
   * @description Update authorization switch
   * @returns IsSuccessRespDto
   */
  public async enabledAuth(
    requestBody: UpdateAuthEnabledDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-auth-enabled",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete application authorization
   * @description Batch delete application authorization
   * @returns IsSuccessRespDto
   */
  public async deleteAuth(authIds: Array<string>): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "DELETE",
      url: "/api/v3/batch-applications-auth",
      params: {
        authIds: authIds,
      },
    });
  }

  /**
   * @summary Get application list
   * @description Get application list
   * @returns ApplicationPaginatedRespDto
   */
  public async listApplications({
    page = 1,
    limit = 10,
    isIntegrateApp = false,
    isSelfBuiltApp = false,
    ssoEnabled = false,
    keywords,
    all,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether it is an integrated application **/
    isIntegrateApp?: boolean;
    /** Whether it is a self-built application **/
    isSelfBuiltApp?: boolean;
    /** Whether single sign-on is enabled **/
    ssoEnabled?: boolean;
    /** Fuzzy search string **/
    keywords?: string;
    /** Search applications, true: search all applications, default is false **/
    all?: boolean;
  }): Promise<ApplicationPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-applications",
      params: {
        page: page,
        limit: limit,
        isIntegrateApp: isIntegrateApp,
        isSelfBuiltApp: isSelfBuiltApp,
        ssoEnabled: ssoEnabled,
        keywords: keywords,
        all: all,
      },
    });
  }

  /**
   * @summary Get application simple information
   * @description Get application simple information by application ID.
   * @returns ApplicationSimpleInfoSingleRespDto
   */
  public async getApplicationSimpleInfo({
    appId,
  }: {
    /** Application ID **/
    appId: string;
  }): Promise<ApplicationSimpleInfoSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-application-simple-info",
      params: {
        appId: appId,
      },
    });
  }

  /**
   * @summary Get application simple information list
   * @description Get application simple information list
   * @returns ApplicationSimpleInfoPaginatedRespDto
   */
  public async listApplicationSimpleInfo({
    page = 1,
    limit = 10,
    isIntegrateApp = false,
    isSelfBuiltApp = false,
    ssoEnabled = false,
    keywords,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Whether it is an integrated application **/
    isIntegrateApp?: boolean;
    /** Whether it is a self-built application **/
    isSelfBuiltApp?: boolean;
    /** Whether single sign-on is enabled **/
    ssoEnabled?: boolean;
    /** Fuzzy search string **/
    keywords?: string;
  }): Promise<ApplicationSimpleInfoPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-application-simple-info",
      params: {
        page: page,
        limit: limit,
        isIntegrateApp: isIntegrateApp,
        isSelfBuiltApp: isSelfBuiltApp,
        ssoEnabled: ssoEnabled,
        keywords: keywords,
      },
    });
  }

  /**
   * @summary Create application
   * @description Create application
   * @returns CreateApplicationRespDto
   */
  public async createApplication(
    requestBody: CreateApplicationDto
  ): Promise<CreateApplicationRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-application",
      data: requestBody,
    });
  }

  /**
   * @summary Update application
   * @description Update application configuration
   * @returns IsSuccessRespDto
   */
  public async updateApplication(
    requestBody: UpdateApplicationDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-application",
      data: requestBody,
    });
  }

  /**
   * @summary Delete application
   * @description Delete application by application ID.
   * @returns IsSuccessRespDto
   */
  public async deleteApplication(
    requestBody: DeleteApplicationDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-application",
      data: requestBody,
    });
  }

  /**
   * @summary Get application secret
   * @description Get application secret
   * @returns GetApplicationSecretRespDto
   */
  public async getApplicationSecret({
    appId,
  }: {
    /** Application ID **/
    appId: string;
  }): Promise<GetApplicationSecretRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-application-secret",
      params: {
        appId: appId,
      },
    });
  }

  /**
   * @summary Refresh application secret
   * @description Refresh application secret
   * @returns RefreshApplicationSecretRespDto
   */
  public async refreshApplicationSecret(
    requestBody: RefreshApplicationSecretDto
  ): Promise<RefreshApplicationSecretRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/refresh-application-secret",
      data: requestBody,
    });
  }

  /**
   * @summary Get current logged in users of application
   * @description Get users who are currently logged in to the application
   * @returns UserPaginatedRespDto
   */
  public async listApplicationActiveUsers(
    requestBody: ListApplicationActiveUsersDto
  ): Promise<UserPaginatedRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-application-active-users",
      data: requestBody,
    });
  }

  /**
   * @summary Get application default access authorization policy
   * @description Get application default access authorization policy
   * @returns GetApplicationPermissionStrategyRespDto
   */
  public async getApplicationPermissionStrategy({
    appId,
  }: {
    /** Application ID **/
    appId: string;
  }): Promise<GetApplicationPermissionStrategyRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-application-permission-strategy",
      params: {
        appId: appId,
      },
    });
  }

  /**
   * @summary Update application default access authorization policy
   * @description Update application default access authorization policy
   * @returns IsSuccessRespDto
   */
  public async updateApplicationPermissionStrategy(
    requestBody: UpdateApplicationPermissionStrategyDataDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-application-permission-strategy",
      data: requestBody,
    });
  }

  /**
   * @summary Authorize application access
   * @description Grant application access permissions to users, groups, organizations or roles. If users, groups, organizations or roles do not exist, they will be skipped and proceed to the next authorization without returning an error
   * @returns IsSuccessRespDto
   */
  public async authorizeApplicationAccess(
    requestBody: AuthorizeApplicationAccessDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/authorize-application-access",
      data: requestBody,
    });
  }

  /**
   * @summary Delete application access authorization records
   * @description Revoke application access permissions from users, groups, organizations or roles. If the input data does not exist, no error will be returned.
   * @returns IsSuccessRespDto
   */
  public async revokeApplicationAccess(
    requestBody: RevokeApplicationAccessDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revoke-application-access",
      data: requestBody,
    });
  }

  /**
   * @summary Check if domain is available
   * @description Check if domain is available for creating new application or updating application domain
   * @returns CheckDomainAvailableSecretRespDto
   */
  public async checkDomainAvailable(
    requestBody: CheckDomainAvailable
  ): Promise<CheckDomainAvailableSecretRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-domain-available",
      data: requestBody,
    });
  }

  /**
   * @summary Update login page configuration
   * @description Update login page configuration by application ID
   * @returns IsSuccessRespDto
   */
  public async updateLoginPageConfig(
    requestBody: UpdateLoginConfigDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-login-page-config",
      data: requestBody,
    });
  }

  /**
   * @summary Modify application MFA settings
   * @description Enable or disable by passing in MFA authentication factor list
   * @returns MFASettingsRespDto
   */
  public async updateApplicationMfaSettings(
    requestBody: UpdateApplicationMfaSettingsDto
  ): Promise<MFASettingsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-application-mfa-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Get user MFA trigger data under application
   * @description Get user MFA trigger data under application
   * @returns GetMapInfoRespDto
   */
  public async getMfaTriggerData({
    appId,
    userId,
    userIdType = "user_id",
  }: {
    /** Application ID **/
    appId: string;
    /** User's unique identifier, can be user ID, username, email, phone number, externalId, ID in external identity source, see userIdType field description for details. Default is user id. **/
    userId: string;
    /** User ID type, default value is `user_id`, optional values are:
     * - `user_id`: GenAuth user ID, such as `6319a1504f3xxxxf214dd5b7`
     * - `phone`: User phone number
     * - `email`: User email
     * - `username`: Username
     * - `external_id`: User ID in external system, corresponding to the `externalId` field of GenAuth user information
     * - `identity`: User's external identity source information, format is `<extIdpId>:<userIdInIdp>`, where `<extIdpId>` is the ID of GenAuth identity source, `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `62f20932716fbcc10d966ee5:ou_8bae746eac07cd2564654140d2a9ac61`.
     * - `sync_relation`: User's external identity source information, format is `<provier>:<userIdInIdp>`, where `<provier>` is the synchronization identity source type, such as wechatwork, lark; `<userIdInIdp>` is the user ID in external identity source.
     * Example value: `lark:ou_8bae746eac07cd2564654140d2a9ac61`.
     *  **/
    userIdType?:
      | "user_id"
      | "external_id"
      | "phone"
      | "email"
      | "username"
      | "identity"
      | "sync_relation"
      | "custom_field";
  }): Promise<GetMapInfoRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-mfa-trigger-data",
      params: {
        appId: appId,
        userId: userId,
        userIdType: userIdType,
      },
    });
  }

  /**
   * @summary Create ASA account
   * @description Create ASA account under an application
   * @returns AsaAccountSingleRespDto
   */
  public async createAsaAccount(
    requestBody: CreateAsaAccountDto
  ): Promise<AsaAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-asa-account",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create ASA accounts
   * @description Batch create ASA accounts under an application
   * @returns IsSuccessRespDto
   */
  public async createAsaAccountBatch(
    requestBody: CreateAsaAccountsBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-asa-accounts-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Update ASA account
   * @description Update information of an ASA account
   * @returns AsaAccountSingleRespDto
   */
  public async updateAsaAccount(
    requestBody: UpdateAsaAccountDto
  ): Promise<AsaAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-asa-account",
      data: requestBody,
    });
  }

  /**
   * @summary Get ASA account list
   * @description Get paginated ASA account list under an application
   * @returns AsaAccountPaginatedRespDto
   */
  public async listAsaAccount({
    appId,
    page = 1,
    limit = 10,
  }: {
    /** Application ID **/
    appId: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<AsaAccountPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-asa-accounts",
      params: {
        appId: appId,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Get ASA account
   * @description Get detailed information of an ASA account by account ID
   * @returns AsaAccountSingleRespDto
   */
  public async getAsaAccount({
    appId,
    accountId,
  }: {
    /** Application ID **/
    appId: string;
    /** ASA account ID **/
    accountId: string;
  }): Promise<AsaAccountSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-asa-account",
      params: {
        appId: appId,
        accountId: accountId,
      },
    });
  }

  /**
   * @summary Batch get ASA accounts
   * @description Batch get detailed information of ASA accounts by account ID list
   * @returns AsaAccountListRespDto
   */
  public async getAsaAccountBatch(
    requestBody: GetAsaAccountBatchDto
  ): Promise<AsaAccountListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-asa-accounts-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Delete ASA account
   * @description Delete ASA account by account ID
   * @returns IsSuccessRespDto
   */
  public async deleteAsaAccount(
    requestBody: DeleteAsaAccountDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-asa-account",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete ASA accounts
   * @description Batch delete ASA accounts by account ID list
   * @returns IsSuccessRespDto
   */
  public async deleteAsaAccountBatch(
    requestBody: DeleteAsaAccountBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-asa-accounts-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Assign ASA account
   * @description Assign ASA account to users, organizations, groups or roles
   * @returns IsSuccessRespDto
   */
  public async assignAsaAccount(
    requestBody: AssignAsaAccountsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/assign-asa-account",
      data: requestBody,
    });
  }

  /**
   * @summary Unassign ASA account
   * @description Unassign ASA account from users, organizations, groups or roles
   * @returns IsSuccessRespDto
   */
  public async unassignAsaAccount(
    requestBody: AssignAsaAccountsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/unassign-asa-account",
      data: requestBody,
    });
  }

  /**
   * @summary Get list of subjects assigned to ASA account
   * @description Get paginated list of subjects that ASA account is assigned to by account ID
   * @returns GetAsaAccountAssignedTargetRespDto
   */
  public async getAsaAccountAssignedTargets({
    appId,
    accountId,
    page = 1,
    limit = 10,
  }: {
    /** Application ID **/
    appId: string;
    /** ASA account ID **/
    accountId: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<GetAsaAccountAssignedTargetRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-asa-account-assigned-targets",
      params: {
        appId: appId,
        accountId: accountId,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Get ASA account assigned to subject
   * @description Get ASA account directly assigned to subject by subject type and identifier
   * @returns AsaAccountSingleNullableRespDto
   */
  public async getAssignedAccount({
    appId,
    targetType,
    targetIdentifier,
  }: {
    /** Application ID **/
    appId: string;
    /** Target object type:
     * - `USER`: User
     * - `ROLE`: Role
     * - `GROUP`: Group
     *  **/
    targetType: "USER" | "ROLE" | "GROUP" | "DEPARTMENT";
    /** Target object unique identifier:
     * - For user, it's user ID, like `6343b98b7cfxxx9366e9b7c`
     * - For role, it's role code, like `admin`
     * - For group, it's group code, like `developer`
     *  **/
    targetIdentifier: string;
  }): Promise<AsaAccountSingleNullableRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-assigned-account",
      params: {
        appId: appId,
        targetType: targetType,
        targetIdentifier: targetIdentifier,
      },
    });
  }

  /**
   * @summary Get security settings
   * @description Get security settings without parameters
   * @returns SecuritySettingsRespDto
   */
  public async getSecuritySettings(): Promise<SecuritySettingsRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-security-settings",
    });
  }

  /**
   * @summary Modify security settings
   * @description Modify security settings including security domain, GenAuth Token validity period (seconds), verification code length, verification code attempt limit, user email change security policy, user phone number change security policy, Cookie expiration settings, whether to disable user registration, frequent registration detection settings, whether to require password setup after verification code registration, whether to block login and send verification email for unverified email login, user self-unlock settings, whether to enable login account selection on GenAuth login page, APP QR code login security settings
   * @returns SecuritySettingsRespDto
   */
  public async updateSecuritySettings(
    requestBody: UpdateSecuritySettingsDto
  ): Promise<SecuritySettingsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-security-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Get global MFA settings
   * @description Get global MFA settings without parameters
   * @returns MFASettingsRespDto
   */
  public async getGlobalMfaSettings(): Promise<MFASettingsRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-global-mfa-settings",
    });
  }

  /**
   * @summary Modify global MFA settings
   * @description Enable by passing in MFA authentication factor list
   * @returns MFASettingsRespDto
   */
  public async updateGlobalMfaSettings(
    requestBody: MFASettingsDto
  ): Promise<MFASettingsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-global-mfa-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Disable global MFA settings
   * @description Disable by passing in MFA authentication factor list
   * @returns MFASettingsRespDto
   */
  public async closeGlobalMfaSettings(
    requestBody: MFADisableSettingsDto
  ): Promise<MFASettingsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/disable-global-mfa-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Create permission namespace
   * @description Create permission namespace, can set permission namespace name, Code and description information
   * @returns CreatePermissionNamespaceResponseDto
   */
  public async createPermissionNamespace(
    requestBody: CreatePermissionNamespaceDto
  ): Promise<CreatePermissionNamespaceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-permission-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create permission namespaces
   * @description Batch create permission namespaces, can set permission namespace name, Code and description information separately
   * @returns IsSuccessRespDto
   */
  public async createPermissionNamespacesBatch(
    requestBody: CreatePermissionNamespacesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-permission-namespaces-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Get permission namespace details
   * @description Get permission namespace details by permission namespace unique identifier (Code)
   * @returns GetPermissionNamespaceResponseDto
   */
  public async getPermissionNamespace({
    code,
  }: {
    /** Permission namespace Code **/
    code: string;
  }): Promise<GetPermissionNamespaceResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-permission-namespace",
      params: {
        code: code,
      },
    });
  }

  /**
   * @summary Batch get permission namespace details list
   * @description Get permission namespace details separately by permission namespace unique identifier (Code)
   * @returns GetPermissionNamespaceListResponseDto
   */
  public async getPermissionNamespacesBatch({
    codes,
  }: {
    /** Permission namespace code list, can use comma to separate for batch **/
    codes: Array<string>;
  }): Promise<GetPermissionNamespaceListResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-permission-namespaces-batch",
      params: {
        codes: codes,
      },
    });
  }

  /**
   * @summary Get paginated permission namespace list
   * @description Get paginated permission namespace list
   * @returns PermissionNamespaceListPaginatedRespDto
   */
  public async listPermissionNamespaces({
    page = 1,
    limit = 10,
    query,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Permission namespace name **/
    query?: string;
  }): Promise<PermissionNamespaceListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-permission-namespaces",
      params: {
        page: page,
        limit: limit,
        query: query,
      },
    });
  }

  /**
   * @summary Update permission namespace
   * @description Update permission namespace, can modify permission namespace name, description and new unique identifier (Code)
   * @returns UpdatePermissionNamespaceResponseDto
   */
  public async updatePermissionNamespace(
    requestBody: UpdatePermissionNamespaceDto
  ): Promise<UpdatePermissionNamespaceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-permission-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Delete permission namespace
   * @description Delete permission namespace information by permission namespace unique identifier (Code)
   * @returns IsSuccessRespDto
   */
  public async deletePermissionNamespace(
    requestBody: DeletePermissionNamespaceDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-permission-namespace",
      data: requestBody,
    });
  }

  /**
   * @summary Batch delete permission namespaces
   * @description Batch delete permission namespace information separately by permission namespace unique identifier (Code)
   * @returns IsSuccessRespDto
   */
  public async deletePermissionNamespacesBatch(
    requestBody: DeletePermissionNamespacesBatchDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-permission-namespaces-batch",
      data: requestBody,
    });
  }

  /**
   * @summary Check if permission namespace Code or name is available
   * @description Check if permission namespace name or Code is valid within permission space by user pool ID and permission namespace Code, or user pool ID and permission namespace name
   * @returns PermissionNamespaceCheckExistsRespDto
   */
  public async checkPermissionNamespaceExists(
    requestBody: CheckPermissionNamespaceExistsDto
  ): Promise<PermissionNamespaceCheckExistsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-permission-namespace-exists",
      data: requestBody,
    });
  }

  /**
   * @summary Get paginated list of all roles under permission namespace
   * @description Get paginated list of all roles under permission namespace, get paginated list of all roles under permission namespace
   * @returns PermissionNamespaceRolesListPaginatedRespDto
   */
  public async listPermissionNamespaceRoles({
    code,
    page = 1,
    limit = 10,
    query,
  }: {
    /** Permission group unique identifier Code **/
    code: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Role Code or name **/
    query?: string;
  }): Promise<PermissionNamespaceRolesListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-permission-namespace-roles",
      params: {
        page: page,
        limit: limit,
        code: code,
        query: query,
      },
    });
  }

  /**
   * @summary Create data resource (recommended, important)
   * @description
   * ## Description
   * This interface is used to create data resources. When you have data that needs to be set with permissions, create corresponding types of data resources according to their data types. Currently we support three types: string, array, and tree.
   * ## Note
   * The `struct` field in the request body needs to pass in different data structures according to different resource types, please refer to the examples below
   * ## Request Examples
   * ### Create string type data resource example
   * When your data can be represented by a single string, you can use this type, for example: an API, a user ID, etc.
   * Here's an example of creating a data resource representing the '/resource/create' API:
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "createResource API",
   * "description": "This is createResource API",
   * "resourceCode": "createResourceAPI",
   * "type": "STRING",
   * "struct": "/resource/create",
   * "actions": ["access"]
   * }
   * ```
   *
   * ### Create array type data resource example
   * When your data is a group of data of the same type, you can use this type, for example: a group of document links, a group of access card numbers, etc.
   * Here's an example of creating a data resource representing a group of access card numbers:
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "A group of access card numbers",
   * "description": "This is a group of access card numbers",
   * "resourceCode": "accessCardNumber",
   * "type": "ARRAY",
   * "struct": ["accessCardNumber1", "accessCardNumber2", "accessCardNumber3"],
   * "actions": ["get", "update"]
   * }
   * ```
   *
   * ### Create tree type data resource example
   * When your data has hierarchical relationships, you can use this type, for example: organizational structure, folder structure, etc.
   * Here's an example of creating a data resource representing a company's organizational structure:
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "GenAuth",
   * "description": "This is GenAuth's organizational structure",
   * "resourceCode": "gen-auth",
   * "type": "TREE",
   * "struct": [
   * {
   * "name": "Product",
   * "code": "product",
   * "value": "product",
   * "children": [
   * {
   * "name": "Product Manager",
   * "code": "productManager",
   * "value": "pm"
   * },
   * {
   * "name": "Design",
   * "code": "design",
   * "value": "ui"
   * }
   * ]
   * },
   * {
   * "name": "Research and Development",
   * "code": "researchAndDevelopment",
   * "value": "rd"
   * }
   * ],
   * "actions": ["get", "update", "delete"]
   * }
   * ```
   *
   * @returns CreateDataResourceResponseDto
   */
  public async createDataResource(
    requestBody: CreateDataResourceDto
  ): Promise<CreateDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Create string data resource
   * @description When you only need to create string type data resources, you can use this API. We have fixed the data resource type, you don't need to pass in the `type` field, note: the `struct` field can only pass in string type data.
   * @returns CreateStringDataResourceResponseDto
   */
  public async createDataResourceByString(
    requestBody: CreateStringDataResourceDto
  ): Promise<CreateStringDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-string-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Create array data resource
   * @description When you only need to create array type data resources, you can use this API. We have fixed the data resource type, you don't need to pass in the `type` field, note: the `struct` field can only pass in array type data.
   * @returns CreateArrayDataResourceResponseDto
   */
  public async createDataResourceByArray(
    requestBody: CreateArrayDataResourceDto
  ): Promise<CreateArrayDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-array-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Create tree data resource
   * @description When you only need to create tree type data resources, you can use this API. We have fixed the data resource type, you don't need to pass in the `type` field, note: `struct` needs to be passed in according to the tree type data resource structure, please refer to the example.
   * @returns CreateTreeDataResourceResponseDto
   */
  public async createDataResourceByTree(
    requestBody: CreateTreeDataResourceDto
  ): Promise<CreateTreeDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-tree-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Get data resource list
   * @description Get data resource list, can filter by data resource name, data resource Code and data resource permission namespace Code list.
   * @returns ListDataResourcesPaginatedRespDto
   */
  public async listDataResources({
    page = 1,
    limit = 10,
    query,
    namespaceCodes,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Keyword search, can be data resource name or data resource Code **/
    query?: string;
    /** Permission data belonging to permission namespace Code list **/
    namespaceCodes?: Array<string>;
  }): Promise<ListDataResourcesPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-data-resources",
      params: {
        page: page,
        limit: limit,
        query: query,
        namespaceCodes: namespaceCodes,
      },
    });
  }

  /**
   * @summary Get data resource details
   * @description Get data resource, query the corresponding data resource information through the data resource ID, including basic information such as data resource name, data resource Code, data resource type (TREE, STRING, ARRAY), data resource permission space ID, data resource permission space Code and data resource operation list.
   * @returns GetDataResourceResponseDto
   */
  public async getDataResource({
    namespaceCode,
    resourceCode,
  }: {
    /** Permission space Code that the data resource belongs to **/
    namespaceCode: string;
    /** Data resource Code, unique within permission space **/
    resourceCode: string;
  }): Promise<GetDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-data-resource",
      params: {
        namespaceCode: namespaceCode,
        resourceCode: resourceCode,
      },
    });
  }

  /**
   * @summary Update data resource
   * @description Update data resource, query original information based on permission space Code and data resource Code, only allow modification of data resource name, description and data resource nodes.
   * @returns UpdateDataResourceResponseDto
   */
  public async updateDataResource(
    requestBody: UpdateDataResourceDto
  ): Promise<UpdateDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Delete data resource
   * @description Delete data resource, delete the corresponding data resource information based on data resource ID.
   * @returns CommonResponseDto
   */
  public async deleteDataResource(
    requestBody: DeleteDataResourceDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-data-resource",
      data: requestBody,
    });
  }

  /**
   * @summary Check if data resource Code or name is available
   * @description Check if data resource name or Code is valid within permission space, determine if it is available in the specified permission space through data resource name or data resource Code and permission space Code.
   *
   * ### Data resource Code valid example
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceCode": "test"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 0,
   * "data": {
   * "isValid": "true"
   * }
   * }
   * ```
   *
   * ### Data resource name valid example
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "test"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 0,
   * "data": {
   * "isValid": "true"
   * }
   * }
   * ```
   *
   * ### Data resource Code invalid example
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceCode": "test"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 0,
   * "requestId": "934108e5-9fbf-4d24-8da1-c330328abd6c",
   * "data": {
   * "isValid": "false",
   * "message": "data resource code already exist"
   * }
   * }
   * ```
   *
   * @returns CheckParamsDataResourceResponseDto
   */
  public async checkDataResourceExists({
    namespaceCode,
    resourceName,
    resourceCode,
  }: {
    /** Permission space Code that the data resource belongs to **/
    namespaceCode: string;
    /** Data resource name, unique within permission space **/
    resourceName?: string;
    /** Data resource Code, unique within permission space **/
    resourceCode?: string;
  }): Promise<CheckParamsDataResourceResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/check-data-resource-exists",
      params: {
        namespaceCode: namespaceCode,
        resourceName: resourceName,
        resourceCode: resourceCode,
      },
    });
  }

  /**
   * @summary Create extension fields for tree type resource
   * @description Create extension fields for tree type resource
   * @returns IsSuccessRespDto
   */
  public async createDnef(
    requestBody: CreateDnefReq
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-dnef",
      data: requestBody,
    });
  }

  /**
   * @summary Batch create extension fields for tree type resource
   * @description Batch create extension fields for tree type resource
   * @returns IsSuccessRespDto
   */
  public async batchCreateDnef(
    requestBody: BatchCreateDnefReq
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/batch-create-dnef",
      data: requestBody,
    });
  }

  /**
   * @summary Delete extension fields for tree type resource
   * @description Delete extension fields for tree type resource
   * @returns IsSuccessRespDto
   */
  public async deleteDnef(
    requestBody: DeleteDnefReq
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-dnef",
      data: requestBody,
    });
  }

  /**
   * @summary Update extension fields for tree type resource
   * @description Update extension fields for tree type resource
   * @returns IsSuccessRespDto
   */
  public async updateDnef(
    requestBody: UpdateDnefReq
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-dnef",
      data: requestBody,
    });
  }

  /**
   * @summary Get list of extension fields for tree type resource
   * @description Get list of extension fields for tree type resource
   * @returns ListDnefPaginatedRespDto
   */
  public async listDnef({
    namespaceCode,
    resourceCode,
    startIndex = 1,
    maxSize = 10,
    query,
  }: {
    /** Permission space Code that the data resource belongs to **/
    namespaceCode: string;
    /** Data resource Code, unique within permission space **/
    resourceCode: string;
    /** Starting index, default is 1, starting from the 1st item **/
    startIndex?: number;
    /** Maximum number of items per query, cannot exceed 50, default is 10 **/
    maxSize?: number;
    /** Keyword search, can be field unique identifier, display name **/
    query?: string;
  }): Promise<ListDnefPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-dnef",
      params: {
        startIndex: startIndex,
        maxSize: maxSize,
        query: query,
        namespaceCode: namespaceCode,
        resourceCode: resourceCode,
      },
    });
  }

  /**
   * @summary Create data policy (Important)
   * @description
   * ## Description
   * This interface is used to create data policies, through which you can bind a group of data resources and their specified operations together to authorize to subjects.
   * ## Note
   * For convenience, we provide a shorthand path-based way for the `permissions` field, such as:
   * - Array, string resources: permission space code/data resource code/data resource action (use `*` to represent all operations)
   * - Tree type resources: permission space code/data resource code/node code 1/node code 1_1/.../data resource action
   *
   * ## Request Example
   * Suppose we want to authorize a developer, first create 3 data resources as follows:
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "Server",
   * "resourceCode": "server_2023",
   * "type": "STRING",
   * "struct": "server_2023",
   * "actions": ["read", "write"]
   * }
   * ```
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "R&D Knowledge Base",
   * "description": "",
   * "resourceCode": "rd_document",
   * "type": "STRING",
   * "struct": "https://www.demo.com/rd_document",
   * "actions": ["read", "write", "share"]
   * }
   * ```
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceName": "R&D Internal Platform Menu",
   * "description": "This is the internal platform menu used by R&D",
   * "resourceCode": "rd_internal_platform",
   * "type": "TREE",
   * "struct": [
   * {
   * "name": "Deploy",
   * "code": "deploy",
   * "children": [
   * {
   * "name": "Production Environment",
   * "code": "prod"
   * },
   * {
   * "name": "Test Environment",
   * "code": "test"
   * }
   * ]
   * },
   * {
   * "name": "Database",
   * "code": "db"
   * "children": [
   * {
   * "name": "Query",
   * "code": "query"
   * },
   * {
   * "name": "Export",
   * "code": "export"
   * }
   * ]
   * }
   * ],
   * "actions": ["access", "execute"]
   * }
   * ```
   * We assign a server: server_2023 for them to use, they can perform any operation on it, meanwhile they can read and edit the R&D knowledge base, and finally they can deploy to the test environment in the R&D internal platform, but cannot export database data.
   * ```json
   * {
   * "policyName": "Developer Policy",
   * "description": "This is an example data policy",
   * "statementList": [
   * {
   * "effect": "ALLOW",
   * "permissions": [
   * "examplePermissionNamespaceCode/server_2023*",
   * "examplePermissionNamespaceCode/rd_document/read",
   * "examplePermissionNamespaceCode/rd_document/write",
   * "examplePermissionNamespaceCode/rd_internal_platform/deploy/test/execute"
   * ]
   * },
   * {
   * "effect": "DENY",
   * "permissions": [
   * "examplePermissionNamespaceCode/rd_internal_platform/db/export/execute"
   * ]
   * }
   * ]
   * }
   * ```
   *
   * @returns CreateDataPolicyResponseDto
   */
  public async createDataPolicy(
    requestBody: CreateDataPolicyDto
  ): Promise<CreateDataPolicyResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-data-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Get data policy list
   * @description Paginate query data policy list, can also fuzzy search data policy name or data policy Code through keywords.
   * @returns ListDataPoliciesPaginatedRespDto
   */
  public async listDataPolices({
    page = 1,
    limit = 10,
    query,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Data policy name keyword search **/
    query?: string;
  }): Promise<ListDataPoliciesPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-data-policies",
      params: {
        page: page,
        limit: limit,
        query: query,
      },
    });
  }

  /**
   * @summary Get simple data policy list
   * @description Paginate get simple data policy list, fuzzy search data policy name or data policy Code to find data policy ID, data policy name and data policy description information.
   * @returns ListSimpleDataPoliciesPaginatedRespDto
   */
  public async listSimpleDataPolices({
    page = 1,
    limit = 10,
    query,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Data policy name keyword search **/
    query?: string;
  }): Promise<ListSimpleDataPoliciesPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-simple-data-policies",
      params: {
        page: page,
        limit: limit,
        query: query,
      },
    });
  }

  /**
   * @summary Get data policy details
   * @description Get data policy details, get corresponding data policy information through data policy ID, including data policy ID, data policy name, data policy description, all data permission lists under the data policy and other information.
   * @returns GetDataPolicyResponseDto
   */
  public async getDataPolicy({
    policyId,
  }: {
    /** Data policy ID **/
    policyId: string;
  }): Promise<GetDataPolicyResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-data-policy",
      params: {
        policyId: policyId,
      },
    });
  }

  /**
   * @summary Update data policy
   * @description Update data policy, modify data policy information through data policy name, data policy description and related data resources and other fields.
   * @returns UpdateDataPolicyResponseDto
   */
  public async updateDataPolicy(
    requestBody: UpdateDataPolicyDto
  ): Promise<UpdateDataPolicyResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-data-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Delete data policy
   * @description Delete data policy, delete corresponding policy through data policy ID, and also delete data policy and corresponding data resource relationship data.
   * @returns CommonResponseDto
   */
  public async deleteDataPolicy(
    requestBody: DeleteDataPolicyDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-data-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Check if data policy name is available
   * @description Query if valid within user pool through data policy name.
   * @returns CheckParamsDataPolicyResponseDto
   */
  public async checkDataPolicyExists({
    policyName,
  }: {
    /** Data policy name, unique within user pool **/
    policyName: string;
  }): Promise<CheckParamsDataPolicyResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/check-data-policy-exists",
      params: {
        policyName: policyName,
      },
    });
  }

  /**
   * @summary Get list of subjects authorized by data policy
   * @description Get list of subjects authorized by data policy, find authorized subject list through authorization subject type, data policy ID and data resource ID.
   * @returns ListDataPolicySubjectPaginatedRespDto
   */
  public async listDataPolicyTargets({
    policyId,
    page = 1,
    limit = 10,
    query,
    targetType,
  }: {
    /** Data policy ID **/
    policyId: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Subject name **/
    query?: string;
    /** Subject type, including four types: USER, GROUP, ROLE, ORG **/
    targetType?: Array<"USER" | "ORG" | "GROUP" | "ROLE">;
  }): Promise<ListDataPolicySubjectPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-data-policy-targets",
      params: {
        policyId: policyId,
        page: page,
        limit: limit,
        query: query,
        targetType: targetType,
      },
    });
  }

  /**
   * @summary Authorize data policy
   * @description Create subject authorization for data policy, authorize through authorization subject and data policy.
   * @returns CommonResponseDto
   */
  public async authorizeDataPolicies(
    requestBody: CreateAuthorizeDataPolicyDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/authorize-data-policies",
      data: requestBody,
    });
  }

  /**
   * @summary Delete data policy authorization
   * @description Delete data policy authorization, delete through authorization subject ID, authorization subject type and data policy ID.
   * @returns CommonResponseDto
   */
  public async revokeDataPolicy(
    requestBody: DeleteAuthorizeDataPolicyDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/revoke-data-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Get user permission list
   * @description
   * ## Description
   * This interface is used to query permission data of data resources in certain permission spaces for certain users.
   * We have multiple authentication interfaces for different authentication scenarios, which differ in the parameter list that can be passed in the scenario and different forms of output parameters. **When you need to query all permissions of certain users**, you can use this interface.
   * ## Note
   * The interface provides two array type input parameters `userIds` and `namespaceCodes` to support batch queries (note: namespaceCodes is optional).
   * ## Scenario Example
   * If your business scenario is that after a user logs in, they can see all documents, personnel information, device information and other resources that they can access or perform other operations on, then you can call this interface to query all user permissions after the user logs in.
   * ## Request Example
   * ### Example of querying single user permission list
   * Note: In the return parameters of this interface, tree type data resource permissions are returned in a **path** way
   * - Input
   *
   * ```json
   * {
   * "userIds": [
   * "6301ceaxxxxxxxxxxx27478"
   * ]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data": {
   * "userPermissionList": [
   * {
   * "userId": "6301ceaxxxxxxxxxxx27478",
   * "namespaceCode": "examplePermissionNamespace",
   * "resourceList": [
   * {
   * "resourceCode": "strCode",
   * "resourceType": "STRING",
   * "strAuthorize": {
   * "value": "Example string resource",
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * },
   * {
   * "resourceCode": "arrayCode",
   * "resourceType": "ARRAY",
   * "arrAuthorize": {
   * "values": [
   * "Example data resource 1",
   * "Example data resource 2"
   * ],
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * },
   * {
   * "resourceCode": "treeCode",
   * "resourceType": "TREE",
   * "treeAuthorize": {
   * "authList": [
   * {
   * "nodePath": "/treeChildrenCode/treeChildrenCode1",
   * "nodeActions": [
   * "read",
   * "get"
   * ],
   * "nodeName": "treeChildrenName1",
   * "nodeValue": "treeChildrenValue1"
   * },
   * {
   * "nodePath": "/treeChildrenCode/treeChildrenCode2",
   * "nodeActions": [
   * "read",
   * "get"
   * ],
   * "nodeName": "treeChildrenName2",
   * "nodeValue": "treeChildrenValue2"
   * },
   * {
   * "nodePath": "/treeChildrenCode/treeChildrenCode3",
   * "nodeActions": [
   * "read"
   * ],
   * "nodeName": "treeChildrenName3",
   * "nodeValue": "treeChildrenValue3"
   * }
   * ]
   * }
   * }
   * ]
   * }
   * ]
   * }
   * }
   * ```
   *
   * ### Example of querying multiple users permission list
   *
   * - Input
   *
   * ```json
   * {
   * "userIds": [
   * "6301ceaxxxxxxxxxxx27478",
   * "6121ceaxxxxxxxxxxx27312"
   * ]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data": {
   * "userPermissionList": [
   * {
   * "userId": "6301ceaxxxxxxxxxxx27478",
   * "namespaceCode": "examplePermissionNamespace1",
   * "resourceList": [
   * {
   * "resourceCode": "strCode",
   * "resourceType": "STRING",
   * "strAuthorize": {
   * "value": "Example string resource",
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * }
   * ]
   * },
   * {
   * "userId": "6121ceaxxxxxxxxxxx27312",
   * "namespaceCode": "examplePermissionNamespace2",
   * "resourceList": [
   * {
   * "resourceCode": "arrayCode",
   * "resourceType": "ARRAY",
   * "arrAuthorize": {
   * "values": [
   * "Example array resource 1",
   * "Example array resource 2"
   * ],
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * }
   * ]
   * }
   * ]
   * }
   * }
   * ```
   *
   * ### Example of querying multiple users permissions in multiple permission spaces
   *
   * - Input
   *
   * ```json
   * {
   * "userIds": [
   * "6301ceaxxxxxxxxxxx27478",
   * "6121ceaxxxxxxxxxxx27312"
   * ],
   * "namespaceCodes": [
   * "examplePermissionNamespace1",
   * "examplePermissionNamespace2"
   * ]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data": {
   * "userPermissionList": [
   * {
   * "userId": "6301ceaxxxxxxxxxxx27478",
   * "namespaceCode": "examplePermissionNamespace1",
   * "resourceList": [
   * {
   * "resourceCode": "strCode1",
   * "resourceType": "STRING",
   * "strAuthorize": {
   * "value": "Example string resource",
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * }
   * ]
   * },
   * {
   * "userId": "6121ceaxxxxxxxxxxx27312",
   * "namespaceCode": "examplePermissionNamespace2",
   * "resourceList": [
   * {
   * "resourceCode": "arrayCode",
   * "resourceType": "ARRAY",
   * "arrAuthorize": {
   * "values": [
   * "Example array resource 1",
   * "Example array resource 2"
   * ],
   * "actions": [
   * "read",
   * "post",
   * "get",
   * "write"
   * ]
   * }
   * }
   * ]
   * }
   * ]
   * }
   * }
   * ```
   *
   * @returns GetUserPermissionListRespDto
   */
  public async getUserPermissionList(
    requestBody: GetUserPermissionListDto
  ): Promise<GetUserPermissionListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-user-permission-list",
      data: requestBody,
    });
  }

  /**
   * @summary Check user permissions (important)
   * @description
   * ## Description
   * You can use this interface when you need to check if a user has specified permissions for certain resources
   * ## Note
   * - This interface locates the corresponding data resource by passing the resource code (for tree type, need to pass the complete code path of the node).
   * - If you configured environment attribute conditions when configuring data policies, you need to set the parameter `judgeConditionEnabled` to `true` (default is false), and pass the environment information (such as IP, device type, system type, etc.) at the time of request through the parameter `authEnvParams`, otherwise the condition judgment will not take effect, causing the data policy to be ineffective.
   *
   * ## Scenario Example
   * When a user deletes certain data, you need to check if they have delete permission for this resource, then you can use this interface.
   *
   * ## Request Example
   * ### Example of checking user permissions for string and array resources (without condition judgment)
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "action": "get",
   * "resources":["strResourceCode1", "arrayResourceCode1"]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data": {
   * "checkResultList": [
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resource": "strResourceCode1",
   * "action": "get",
   * "enabled": true
   * },
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resource": "arrayResourceCode1",
   * "action": "get",
   * "enabled": true
   * }
   * ]
   * }
   * }
   * ```
   *
   * ### Example of checking user permissions for string and array resources (with condition judgment enabled)
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "action": "get",
   * "resources": ["strResourceCode1", "arrayResourceCode1"],
   * "judgeConditionEnabled": true,
   * "authEnvParams":{
   * "ip":"110.96.0.0",
   * "city":"Beijing",
   * "province":"Beijing",
   * "country":"China",
   * "deviceType":"PC",
   * "systemType":"ios",
   * "browserType":"IE",
   * "requestDate":"2022-12-26 17:40:00"
   * }
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data": {
   * "checkResultList": [
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resource": "strResourceCode1",
   * "action": "get",
   * "enabled": false
   * },
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "resource": "arrayResourceCode1",
   * "action": "get",
   * "enabled": false
   * }
   * ]
   * }
   * }
   * ```
   *
   * ### Example of checking user permissions for tree resources
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "action": "get",
   * "resources":["treeResourceCode1/StructCode1/resourceStructChildrenCode1", "treeResourceCode2/StructCode1/resourceStructChildrenCode1"]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "checkResultList": [{
   * "namespaceCode": "examplePermissionNamespace",
   * "action": "get",
   * "resource": "treeResourceCode1/StructCode1/resourceStructChildrenCode1",
   * "enabled": true
   * },{
   * "namespaceCode": "examplePermissionNamespace",
   * "action": "get",
   * "resource": "treeResourceCode2/StructCode1/resourceStructChildrenCode1",
   * "enabled": true
   * }]
   * }
   * }
   * ```
   *
   * @returns CheckPermissionRespDto
   */
  public async checkPermission(
    requestBody: CheckPermissionDto
  ): Promise<CheckPermissionRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-permission",
      data: requestBody,
    });
  }

  /**
   * @summary Check external user permissions
   * @description
   * ## Description
   * When your user is an external user and you need to check if they have certain permissions for a resource, you can use this interface by passing the user's ID through `externalId`
   *
   * @returns CheckExternalUserPermissionRespDto
   */
  public async checkExternalUserPermission(
    requestBody: CheckExternalUserPermissionDto
  ): Promise<CheckExternalUserPermissionRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-external-user-permission",
      data: requestBody,
    });
  }

  /**
   * @summary Get user's permission list for certain resources (recommended)
   * @description
   * ## Description
   * You can use this interface when you need to query the permissions a user has for a specified resource list.
   * ## Note
   * This interface requires you to pass the specified resource code (for tree type resources, need to pass the complete code path of the node). This interface has better performance and is recommended.
   * ## Request Example
   * ### Example of getting user permissions for string and array resources
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "resources":["strResourceCode1", "arrayResourceCode1"]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   *
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "permissionList": [{
   * "namespaceCode": "examplePermissionNamespace",
   * "actions": ["read","get"],
   * "resource": "strResourceCode1"
   * },{
   * "namespaceCode": "examplePermissionNamespace",
   * "actions": ["read","update","delete"],
   * "resource": "arrayResourceCode1"
   * }]
   * }
   * }
   * ```
   *
   * ### Example of getting user permissions for tree resources
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "resources":["treeResourceCode1/StructCode1/resourceStructChildrenCode1", "treeResourceCode2/StructCode1/resourceStructChildrenCode1"]
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "permissionList": [{
   * "namespaceCode": "examplePermissionNamespace",
   * "actions": ["read", "update", "delete"],
   * "resource": "treeResourceCode1/StructCode1/resourceStructChildrenCode1"
   * },{
   * "namespaceCode": "examplePermissionNamespace",
   * "actions": ["read", "get", "delete"],
   * "resource": "treeResourceCode2/StructCode1/resourceStructChildrenCode1"
   * }]
   * }
   * }
   * ```
   *
   * @returns GetUserResourcePermissionListRespDto
   */
  public async getUserResourcePermissionList(
    requestBody: GetUserResourcePermissionListDto
  ): Promise<GetUserResourcePermissionListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-user-resource-permission-list",
      data: requestBody,
    });
  }

  /**
   * @summary Get external user's resource structure and permissions
   * @description
   * ## Description
   * When you need to get the permissions an external user (passing external user ID through `externalId` parameter) has for a resource and need the structure information of this resource (tree type resources return tree structure, array type resources return array, string type return string), you can use this interface.
   * ## Request Example
   * ### Example of getting user authorized string data resource
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "externalId": "63721xxxxxxxxxxxxdde14a3",
   * "resourceCode": "exampleStrResourceCode"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "namespaceCode": "exampleNamespaceCode",
   * "resourceCode": "exampleStrResourceCode",
   * "resourceType": "STRING",
   * "strResourceAuthAction":{
   * "value": "strTestValue",
   * "actions": ["get","delete"]
   * }
   * }
   * }
   * ```
   *
   *
   * ### Example of getting user authorized array data resource
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "externalId": "63721xxxxxxxxxxxxdde14a3",
   * "resourceCode": "exampleArrResourceCode"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "namespaceCode": "exampleNamespaceCode",
   * "resourceCode": "exampleArrResourceCode",
   * "resourceType": "ARRAY",
   * "arrResourceAuthAction":{
   * "values": ["arrTestValue1","arrTestValue2","arrTestValue3"],
   * "actions": ["get","delete"]
   * }
   * }
   * }
   * ```
   *
   *
   * ### Example of getting user authorized tree data resource
   *
   * - Input
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "externalId": "63721xxxxxxxxxxxxdde14a3",
   * "resourceCode": "exampleTreeResourceCode"
   * }
   * ```
   *
   * - Output
   *
   * ```json
   * {
   * "statusCode": 200,
   * "message": "Operation successful",
   * "apiCode": 20001,
   * "data":{
   * "namespaceCode": "exampleNamespaceCode",
   * "resourceCode": "exampleArrResourceCode",
   * "resourceType": "TREE",
   * "treeResourceAuthAction":{
   * "nodeAuthActionList":[{
   * "code": "tree11",
   * "name": "tree11",
   * "value": "test11Value",
   * "actions": ["get","delete"],
   * "children": [{
   * "code": "tree111",
   * "name": "tree111",
   * "value": "test111Value",
   * "actions": ["update","read"],
   * }]
   * },{
   * "code": "tree22",
   * "name": "tree22",
   * "value": "test22Value",
   * "actions": ["get","delete"]
   * }]
   * }
   * }
   * }
   * ```
   *
   * @returns GetExternalUserResourceStructRespDto
   */
  public async getExternalUserResourceStruct(
    requestBody: GetExternalUserResourceStructDto
  ): Promise<GetExternalUserResourceStructRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-external-user-resource-struct",
      data: requestBody,
    });
  }

  /**
   * @summary Check user permissions at same level in tree resource (recommended)
   * @description
   * ## Description
   * This interface is used to check if a user has certain permissions for some nodes at the **same level** of a tree resource. Since tree type resources are commonly used, we added this interface specifically for checking node permissions of tree type resources based on the business scenario of "checking if a user has resource permissions".
   * ## Note
   * We locate a certain level of the tree type data resource through the `resource` parameter (so this parameter is passed in the format of `resource code/node code path`), and locate which nodes at the current level through the `resourceNodeCodes` parameter.
   * ## Scenario Example
   * If your business scenario is: When a user deletes some files under a folder in a file system, you need to check if they have delete permissions for these files, then you can use this interface.
   * ## Request Example
   * ### Example of checking user permissions at same level in tree resource (without condition judgment)
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "action": "read",
   * "resource": "treeResourceCode/structCode",
   * "resourceNodeCodes": ["resourceStructChildrenCode1","resourceStructChildrenCode2","resourceStructChildrenCode3"]
   * }
   * ```
   *
   * ### Example of checking user permissions at same level in tree resource (with condition judgment enabled)
   *
   * ```json
   * {
   * "namespaceCode": "examplePermissionNamespace",
   * "userId": "63721xxxxxxxxxxxxdde14a3",
   * "action": "read",
   * "resource": "treeResourceCode/structCode",
   * "resourceNodeCodes": ["resourceStructChildrenCode1","resourceStructChildrenCode2","resourceStructChildrenCode3"],
   * "judgeConditionEnabled": true,
   * "authEnvParams":{
   * "ip":"110.96.0.0",
   * "city":"Beijing",
   * "province":"Beijing",
   * "country":"China",
   * "deviceType":"PC",
   * "systemType":"ios",
   * "browserType":"IE",
   * "requestDate":"2022-12-26 17:40:00"
   * }
   * }
   * ```
   *
   * @returns CheckUserSameLevelPermissionResponseDto
   */
  public async checkUserSameLevelPermission(
    requestBody: CheckUserSameLevelPermissionDto
  ): Promise<CheckUserSameLevelPermissionResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/check-user-same-level-permission",
      data: requestBody,
    });
  }

  /**
   * @summary Get permission view data list
   * @description
   * ## Description
   * This interface is used to export menu: Permission Management -> Data Permission -> Permission View List Data. If you need to pull our data permission authorization data (all permissions of all resources owned by all users), you can use this interface.
   *
   * @returns ListPermissionViewResponseDto
   */
  public async listPermissionView(
    requestBody: ListPermissionViewDto
  ): Promise<ListPermissionViewResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/list-permission-view/data",
      data: requestBody,
    });
  }

  /**
   * @summary Get package details
   * @description Get current user pool package details.
   * @returns CostGetCurrentPackageRespDto
   */
  public async getCurrentPackageInfo(): Promise<CostGetCurrentPackageRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-current-package-info",
    });
  }

  /**
   * @summary Get usage details
   * @description Get current user pool usage details.
   * @returns CostGetCurrentUsageRespDto
   */
  public async getUsageInfo(): Promise<CostGetCurrentUsageRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-usage-info",
    });
  }

  /**
   * @summary Get MAU usage records
   * @description Get current user pool MAU usage records
   * @returns CostGetMauPeriodUsageHistoryRespDto
   */
  public async getMauPeriodUsageHistory({
    startTime,
    endTime,
  }: {
    /** Start time (year month day) **/
    startTime: string;
    /** End time (year month day) **/
    endTime: string;
  }): Promise<CostGetMauPeriodUsageHistoryRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-mau-period-usage-history",
      params: {
        startTime: startTime,
        endTime: endTime,
      },
    });
  }

  /**
   * @summary Get all rights
   * @description Get all rights of current user pool
   * @returns CostGetAllRightItemRespDto
   */
  public async getAllRightsItem(): Promise<CostGetAllRightItemRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-all-rights-items",
    });
  }

  /**
   * @summary Get order list
   * @description Get current user pool order list
   * @returns CostGetOrdersRespDto
   */
  public async getOrders({
    page = 1,
    limit = 10,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<CostGetOrdersRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-orders",
      params: {
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Get order details
   * @description Get current user pool order details
   * @returns CostGetOrderDetailRespDto
   */
  public async getOrderDetail({
    orderNo,
  }: {
    /** Order number **/
    orderNo: string;
  }): Promise<CostGetOrderDetailRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-order-detail",
      params: {
        orderNo: orderNo,
      },
    });
  }

  /**
   * @summary Get order payment details
   * @description Get current user pool order payment details
   * @returns CostGetOrderPayDetailRespDto
   */
  public async getOrderPayDetail({
    orderNo,
  }: {
    /** Order number **/
    orderNo: string;
  }): Promise<CostGetOrderPayDetailRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-order-pay-detail",
      params: {
        orderNo: orderNo,
      },
    });
  }

  /**
   * @summary Create custom event application
   * @description Create custom event application
   * @returns CommonResponseDto
   */
  public async createEventApp(
    requestBody: CreateEventAppDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-event-app",
      data: requestBody,
    });
  }

  /**
   * @summary Get event application list
   * @description Get event application list
   * @returns EventAppPaginatedRespDto
   */
  public async listEventApps(): Promise<EventAppPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-event-apps",
    });
  }

  /**
   * @summary Get event list
   * @description Get all event list supported by GenAuth service
   * @returns OpenEventPaginatedRespDto
   */
  public async listEvents({
    page = 1,
    limit = 10,
    app,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
    /** Application type **/
    app?: string;
  }): Promise<OpenEventPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-events",
      params: {
        page: page,
        limit: limit,
        app: app,
      },
    });
  }

  /**
   * @summary Define custom event
   * @description Define custom events in GenAuth event center
   * @returns CommonResponseDto
   */
  public async defineEvent(
    requestBody: DefineEventDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/define-event",
      data: requestBody,
    });
  }

  /**
   * @summary Push custom event
   * @description Push custom events to GenAuth event center
   * @returns PubEventRespDto
   */
  public async verifyEvent(requestBody: PubEventDto): Promise<PubEventRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/pub-event",
      data: requestBody,
    });
  }

  /**
   * @summary Push custom event from authentication endpoint
   * @description Push custom events from authentication endpoint to GenAuth event center
   * @returns PubEventRespDto
   */
  public async pubUserEvent(
    requestBody: PubEventDto
  ): Promise<PubEventRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/pub-userEvent",
      data: requestBody,
    });
  }

  /**
   * @summary Create application registration whitelist
   * @description You need to specify the registration whitelist type and data to create
   * @returns WhitelistListRespDto
   */
  public async addWhitelistOfApp(
    requestBody: AddWhitelistOfAppDto
  ): Promise<WhitelistListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-whitelist-of-app",
      data: requestBody,
    });
  }

  /**
   * @summary Get application registration whitelist
   * @description Get registration whitelist, can specify page number and page size
   * @returns WhitelistListRespDto
   */
  public async listWhitelistsOfApp({
    type,
    appId,
  }: {
    /** Whitelist type **/
    type: "USERNAME" | "EMAIL" | "PHONE";
    /** APP ID **/
    appId: string;
  }): Promise<WhitelistListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-whitelist-of-app",
      params: {
        type: type,
        appId: appId,
      },
    });
  }

  /**
   * @summary Delete application registration whitelist
   * @description Delete registration whitelist by specifying multiple whitelist data in array format
   * @returns IsSuccessDto
   */
  public async deleteWhitelistOfApp(
    requestBody: DeleteWhitelistOfAppDto
  ): Promise<IsSuccessDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-whitelist-of-app",
      data: requestBody,
    });
  }

  /**
   * @summary Create registration whitelist
   * @description You need to specify the registration whitelist type and data to create
   * @returns WhitelistListRespDto
   */
  public async addWhitelist(
    requestBody: AddWhitelistDto
  ): Promise<WhitelistListRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-whitelist",
      data: requestBody,
    });
  }

  /**
   * @summary Get registration whitelist
   * @description Get registration whitelist, can specify page number and page size
   * @returns WhitelistListRespDto
   */
  public async listWhitelists({
    type,
  }: {
    /** Whitelist type **/
    type: "USERNAME" | "EMAIL" | "PHONE";
  }): Promise<WhitelistListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-whitelist",
      params: {
        type: type,
      },
    });
  }

  /**
   * @summary Delete registration whitelist
   * @description Delete registration whitelist by specifying multiple whitelist data in array format
   * @returns IsSuccessDto
   */
  public async deleteWhitelist(
    requestBody: DeleteWhitelistDto
  ): Promise<IsSuccessDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-whitelist",
      data: requestBody,
    });
  }

  /**
   * @summary Get IP list
   * @description Get IP list with pagination
   * @returns IpListPaginatedRespDto
   */
  public async findIpList({
    ipType,
    page = 1,
    limit = 10,
  }: {
    /** IP type **/
    ipType: "BLACK" | "WHITE";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<IpListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/ip-list",
      params: {
        page: page,
        limit: limit,
        ipType: ipType,
      },
    });
  }

  /**
   * @summary Create IP list
   * @description Create IP list
   * @returns CommonResponseDto
   */
  public async add(requestBody: IpListCreateDto): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/ip-list",
      data: requestBody,
    });
  }

  /**
   * @summary Delete IP list
   * @description Delete IP list
   * @returns CommonResponseDto
   */
  public async deleteById(id: string): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "DELETE",
      url: "/api/v3/ip-list/{id}",
    });
  }

  /**
   * @summary Get risk list users
   * @description Get risk list users with pagination
   * @returns UserListPaginatedRespDto
   */
  public async findUserList({
    userListType,
    page = 1,
    limit = 10,
  }: {
    /** IP type **/
    userListType: "BLACK" | "WHITE";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<UserListPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/user-list",
      params: {
        page: page,
        limit: limit,
        userListType: userListType,
      },
    });
  }

  /**
   * @summary Create user list
   * @description Create user list
   * @returns CommonResponseDto
   */
  public async addUser(
    requestBody: UserListCreateDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/user-list",
      data: requestBody,
    });
  }

  /**
   * @summary Delete user list
   * @description Delete user list
   * @returns CommonResponseDto
   */
  public async deleteUserListById(id: string): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "DELETE",
      url: "/api/v3/user-list/{id}",
    });
  }

  /**
   * @summary Get risk policy list
   * @description Get risk policy list with pagination
   * @returns UserListPolicyPaginatedRespDto
   */
  public async findRiskListPolicy({
    optObject,
    page = 1,
    limit = 10,
  }: {
    /** Policy operation object, currently only ip **/
    optObject: "IP" | "USER";
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<UserListPolicyPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/risk-list-policy",
      params: {
        page: page,
        limit: limit,
        optObject: optObject,
      },
    });
  }

  /**
   * @summary Create risk policy
   * @description Create risk policy
   * @returns CommonResponseDto
   */
  public async addRiskListPolicy(
    requestBody: RiskListPolicyCreateDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/risk-list-policy",
      data: requestBody,
    });
  }

  /**
   * @summary Delete risk policy
   * @description Delete risk policy
   * @returns CommonResponseDto
   */
  public async deleteRiskListPolicyById(
    id: string
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "DELETE",
      url: "/api/v3/risk-list-policy/{id}",
    });
  }

  /**
   * @summary Get device exclusion rule configuration
   * @description Get device exclusion rule configuration
   * @returns GetDeviceExclusiveRuleRespDto
   */
  public async getRuleSettings(): Promise<GetDeviceExclusiveRuleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-device-exclusive-rule-settings",
    });
  }

  /**
   * @summary Update device exclusion rule configuration
   * @description Update device exclusion rule configuration
   * @returns GetDeviceExclusiveRuleRespDto
   */
  public async updateRuleSettings(
    requestBody: UpdateDeviceExclusiveRuleDto
  ): Promise<GetDeviceExclusiveRuleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-device-exclusive-rule-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Get device exclusion scope configuration
   * @description Get device exclusion scope configuration
   * @returns GetDeviceExclusiveValidScopeRespDto
   */
  public async getAllValidScopeSettings(): Promise<GetDeviceExclusiveValidScopeRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-device-exclusive-valid-scope-settings",
    });
  }

  /**
   * @summary Get application list supporting device exclusion scope
   * @description Get application list supporting device exclusion scope
   * @returns GetDeviceExclusiveValidScopeAppRespDto
   */
  public async findAppLists({
    keyword,
  }: {
    keyword: string;
  }): Promise<GetDeviceExclusiveValidScopeAppRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-supported-device-exclusive-apps",
      params: {
        keyword: keyword,
      },
    });
  }

  /**
   * @summary Save device exclusion scope configuration
   * @description Save device exclusion scope configuration
   * @returns IsSuccessRespDto
   */
  public async saveInvitationPolicies(
    requestBody: SaveDeviceExclusiveValidScopeSettingsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/save-device-exclusive-valid-scope-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Remove device exclusion scope configuration
   * @description Remove device exclusion scope configuration
   * @returns IsSuccessRespDto
   */
  public async remove(
    requestBody: DeleteDeviceExclusiveValidScopeSettingsByIdsDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/remove-device-exclusive-valid-scope-settings",
      data: requestBody,
    });
  }

  /**
   * @summary Get device exclusion whitelist configuration
   * @description Get device exclusion whitelist configuration
   * @returns GetDeviceExclusiveWhiteListRespDto
   */
  public async getAllWhiteListSettings(): Promise<GetDeviceExclusiveWhiteListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-device-exclusive-white-list-settings",
    });
  }

  /**
   * @deprecated
   * @summary Add device
   * @description Interface response not standardized, recommend using /api/v3/add-device to create new device
   * @returns TerminalInfoRespDto
   */
  public async createDevice(
    requestBody: CreateTerminalDto
  ): Promise<TerminalInfoRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-device",
      data: requestBody,
    });
  }

  /**
   * @summary Add device
   * @description Create new device
   * @returns TerminalInfoRespDto
   */
  public async addDevice(
    requestBody: CreateTerminalDto
  ): Promise<TerminalInfoRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/add-device",
      data: requestBody,
    });
  }

  /**
   * @deprecated
   * @summary Recent login applications
   * @description Interface response not standardized, recommend using /api/v3/get-last-login-apps-by-device-ids to get recently logged in application list by device unique identifier
   * @returns CommonResponseDto
   */
  public async findLastLoginAppsByDeviceIds(
    requestBody: QueryTerminalAppsDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-last-login-apps-by-deviceIds",
      data: requestBody,
    });
  }

  /**
   * @summary Recent login applications
   * @description Get recently logged in application list by device unique identifier
   * @returns CommonResponseDto
   */
  public async findLastLoginAppsByDeviceIdsV2(
    requestBody: QueryTerminalAppsDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-last-login-apps-by-device-ids",
      data: requestBody,
    });
  }

  /**
   * @summary Create Pipeline function
   * @description Create Pipeline function
   * @returns PipelineFunctionSingleRespDto
   */
  public async createPipelineFunction(
    requestBody: CreatePipelineFunctionDto
  ): Promise<PipelineFunctionSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-pipeline-function",
      data: requestBody,
    });
  }

  /**
   * @summary Get Pipeline function details
   * @description Get Pipeline function details
   * @returns PipelineFunctionSingleRespDto
   */
  public async getPipelineFunction({
    funcId,
  }: {
    /** Pipeline function ID **/
    funcId: string;
  }): Promise<PipelineFunctionSingleRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-pipeline-function",
      params: {
        funcId: funcId,
      },
    });
  }

  /**
   * @deprecated
   * @summary Re-upload Pipeline function
   * @description Re-upload Pipeline function when upload fails
   * @returns PipelineFunctionSingleRespDto
   */
  public async reuploadPipelineFunction(
    requestBody: ReUploadPipelineFunctionDto
  ): Promise<PipelineFunctionSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/reupload-pipeline-function",
      data: requestBody,
    });
  }

  /**
   * @summary Update Pipeline function
   * @description Update Pipeline function
   * @returns PipelineFunctionSingleRespDto
   */
  public async updatePipelineFunction(
    requestBody: UpdatePipelineFunctionDto
  ): Promise<PipelineFunctionSingleRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-pipeline-function",
      data: requestBody,
    });
  }

  /**
   * @summary Update Pipeline function order
   * @description Update Pipeline function order
   * @returns CommonResponseDto
   */
  public async updatePipelineOrder(
    requestBody: UpdatePipelineOrderDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-pipeline-order",
      data: requestBody,
    });
  }

  /**
   * @summary Delete Pipeline function
   * @description Delete Pipeline function
   * @returns CommonResponseDto
   */
  public async deletePipelineFunction(
    requestBody: DeletePipelineFunctionDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-pipeline-function",
      data: requestBody,
    });
  }

  /**
   * @summary Get Pipeline function list
   * @description Get Pipeline function list
   * @returns PipelineFunctionPaginatedRespDto
   */
  public async listPipelineFunctions({
    scene,
  }: {
    /** Filter by function trigger scene (optional, returns all by default):
     * - `PRE_REGISTER`: Before registration
     * - `POST_REGISTER`: After registration
     * - `PRE_AUTHENTICATION`: Before authentication
     * - `POST_AUTHENTICATION`: After authentication
     * - `PRE_OIDC_ID_TOKEN_ISSUED`: Before OIDC ID Token issuance
     * - `PRE_OIDC_ACCESS_TOKEN_ISSUED`: Before OIDC Access Token issuance
     * - `PRE_COMPLETE_USER_INFO`: Before completing user info
     *  **/
    scene:
      | "PRE_REGISTER"
      | "POST_REGISTER"
      | "PRE_AUTHENTICATION"
      | "POST_AUTHENTICATION"
      | "PRE_OIDC_ID_TOKEN_ISSUED"
      | "PRE_OIDC_ACCESS_TOKEN_ISSUED"
      | "PRE_COMPLETE_USER_INFO"
      | "PRE_MFA_VERIFY"
      | "POST_MFA_VERIFY";
  }): Promise<PipelineFunctionPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-pipeline-functions",
      params: {
        scene: scene,
      },
    });
  }

  /**
   * @summary Get Pipeline logs
   * @description Get Pipeline logs
   * @returns PipelineFunctionPaginatedRespDto
   */
  public async getPipelineLogs({
    funcId,
    page = 1,
    limit = 10,
  }: {
    /** Pipeline function ID **/
    funcId: string;
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<PipelineFunctionPaginatedRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-pipeline-logs",
      params: {
        funcId: funcId,
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Create Webhook
   * @description You need to specify Webhook name, callback URL, request data format, real user name to create Webhook. Can optionally enable and set request secret key
   * @returns CreateWebhookRespDto
   */
  public async createWebhook(
    requestBody: CreateWebhookDto
  ): Promise<CreateWebhookRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-webhook",
      data: requestBody,
    });
  }

  /**
   * @summary Get Webhook list
   * @description Get Webhook list, can specify page number and page size
   * @returns GetWebhooksRespDto
   */
  public async listWebhooks({
    page = 1,
    limit = 10,
  }: {
    /** Current page number, starting from 1 **/
    page?: number;
    /** Number per page, maximum cannot exceed 50, default is 10 **/
    limit?: number;
  }): Promise<GetWebhooksRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-webhooks",
      params: {
        page: page,
        limit: limit,
      },
    });
  }

  /**
   * @summary Update Webhook configuration
   * @description Need to specify webhookId, can optionally update Webhook name, callback URL, request data format, real user name, enable status, request secret key parameters
   * @returns UpdateWebhooksRespDto
   */
  public async updateWebhook(
    requestBody: UpdateWebhookDto
  ): Promise<UpdateWebhooksRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-webhook",
      data: requestBody,
    });
  }

  /**
   * @summary Delete Webhook
   * @description Delete Webhook by specifying multiple webhookIds in array format, no error prompt if webhookId does not exist
   * @returns IsSuccessRespDto
   */
  public async deleteWebhook(
    requestBody: DeleteWebhookDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-webhook",
      data: requestBody,
    });
  }

  /**
   * @summary Get Webhook logs
   * @description Get Webhook logs by specifying webhookId, optional page and limit, no error returned if webhookId does not exist
   * @returns ListWebhookLogsRespDto
   */
  public async getWebhookLogs(
    requestBody: ListWebhookLogs
  ): Promise<ListWebhookLogsRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/get-webhook-logs",
      data: requestBody,
    });
  }

  /**
   * @summary Manually trigger Webhook execution
   * @description Manually trigger Webhook execution by specifying webhookId, optional request headers and body
   * @returns TriggerWebhookRespDto
   */
  public async triggerWebhook(
    requestBody: TriggerWebhookDto
  ): Promise<TriggerWebhookRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/trigger-webhook",
      data: requestBody,
    });
  }

  /**
   * @summary Get Webhook details
   * @description Get Webhook details by specified webhookId
   * @returns GetWebhookRespDto
   */
  public async getWebhook({
    webhookId,
  }: {
    /** Webhook ID **/
    webhookId: string;
  }): Promise<GetWebhookRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-webhook",
      params: {
        webhookId: webhookId,
      },
    });
  }

  /**
   * @summary Get Webhook event list
   * @description Returns event list and category list
   * @returns WebhookEventListRespDto
   */
  public async getWebhookEventList(): Promise<WebhookEventListRespDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-webhook-event-list",
    });
  }

  /**
   * @summary Get collaborator AK/SK list
   * @description Get all AK/SK list under collaborator by collaborator Id
   * @returns ListAccessKeyResponseDto
   */
  public async getAccessKeyList({
    userId,
    type,
    status,
  }: {
    /** User ID that key belongs to **/
    userId?: string;
    /** Key type **/
    type?: string;
    /** AccessKey status, activated: activated, staging: staged (can be rotated), revoked: revoked **/
    status?: Array<string>;
  }): Promise<ListAccessKeyResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/list-access-key",
      params: {
        userId: userId,
        type: type,
        status: status,
      },
    });
  }

  /**
   * @summary Get collaborator AK/SK details
   * @description Get collaborator AK/SK details by collaborator ID and accessKeyId
   * @returns GetAccessKeyResponseDto
   */
  public async getAccessKey({
    userId,
    accessKeyId,
  }: {
    /** User ID **/
    userId: string;
    /** accessKeyId **/
    accessKeyId: string;
  }): Promise<GetAccessKeyResponseDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/get-access-key",
      params: {
        userId: userId,
        accessKeyId: accessKeyId,
      },
    });
  }

  /**
   * @summary Create collaborator AK/SK
   * @description Create collaborator AK/SK by collaborator ID
   * @returns CreateAccessKeyResponseDto
   */
  public async createAccessKey(
    requestBody: CreateAccessKeyDto
  ): Promise<CreateAccessKeyResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/create-access-key",
      data: requestBody,
    });
  }

  /**
   * @summary Delete collaborator AK/SK
   * @description Delete collaborator AK/SK by selected accessKeyId
   * @returns CommonResponseDto
   */
  public async deleteAccessKey(
    requestBody: DeleteAccessKeyDto
  ): Promise<CommonResponseDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/delete-access-key",
      data: requestBody,
    });
  }

  /**
   * @summary Update an admin AccessKey
   * @description Update an admin AccessKey by AccessKeyId, currently only supports updating status, status supports activated / revoked
   * @returns IsSuccessRespDto
   */
  public async updateAccessKey(
    requestBody: UpdateAccessKeyDto
  ): Promise<IsSuccessRespDto> {
    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/update-access-key",
      data: requestBody,
    });
  }

  /**
   * @summary Get verify-config-app list
   * @description Get verify-config-app list
   * @returns ApplicationDto
   */
  public async getVerifyConfigApp({
    keywords,
  }: {
    /** Search keywords **/
    keywords?: string;
  }): Promise<ApplicationDto> {
    return await this.httpClient.request({
      method: "GET",
      url: "/api/v3/verify-config-app",
      params: {
        keywords: keywords,
      },
    });
  }

  /**
   * @summary Socket reconnection
   * @returns
   */
  private reconnect(eventName: string) {
    return new Promise((resolve, reject) => {
      if (
        this.options.retryTimes &&
        this.wsMap[eventName].timeConnect < this.options.retryTimes
      ) {
        if (!this.wsMap[eventName].lockConnect) {
          this.wsMap[eventName].lockConnect = true;
          this.wsMap[eventName].timeConnect++;
          setTimeout(() => {
            this.wsMap[eventName].lockConnect = false;
            this.initWebSocket(eventName, true)
              .then((res) => {
                resolve(true);
              })
              .catch((e) => {
                reject(e);
              });
          }, 2000);
        }
      } else {
        reject(`Socket service connection timeout`);
      }
    });
  }

  /**
   * @summary Establish socket connection, listen for message callback event queue
   * @returns
   */
  private initWebSocket(eventName: string, retry?: boolean) {
    return new Promise((resolve, reject) => {
      if (!this.wsMap[eventName] || retry) {
        this.wsMap[eventName] = {
          socket: new WebSocket(
            `${this.options.socketUri}/events/v1/management/sub?code=${eventName}`,
            {
              headers: {
                // Build token
                authorization: buildAuthorization(
                  this.options.accessKeyId,
                  this.options.accessKeySecret,
                  buildStringToSign("websocket", "", {}, {})
                ),
              },
            }
          ),
          timeConnect: retry ? this.wsMap[eventName].timeConnect : 0,
          lockConnect: false,
        };

        this.wsMap[eventName].socket.on("open", () => {
          resolve(true);
        });

        this.wsMap[eventName].socket.on("message", (data: Buffer) => {
          try {
            if (this.eventBus[eventName]) {
              this.eventBus[eventName].forEach((callback) => {
                callback[0](data.toString("utf8"));
              });
            } else {
              // Unsubscribed event
              console.warn("Unsubscribed event:", eventName);
            }
          } catch (error) {
            return reject(
              `Data formatting error, check transmission data format!!! ${error}`
            );
          }
        });

        this.wsMap[eventName].socket.on("error", async (e) => {
          try {
            await this.reconnect(eventName);
            resolve(true);
          } catch (error) {
            return reject(`Socket connection error: ${e}`);
          }
        });

        this.wsMap[eventName].socket.on("close", async () => {
          try {
            await this.reconnect(eventName);
            resolve(true);
          } catch (error) {
            return reject(`Socket connection closed`);
          }
        });
      } else {
        resolve(true);
      }
    });
  }

  /**
   * @summary Event subscription
   * @description After subscribing, receive server message callbacks through establishing socket connection
   * @returns
   */
  public sub(eventName: string, callback: Function, errCallback: Function) {
    /**
     * 1. Check if socket is connected
     * 2. Get socket instance
     * 3. Subscribe
     */
    if (typeof eventName !== "string") {
      throw new Error("Subscription event name must be string type!!!");
    }

    if (typeof callback !== "function") {
      throw new Error("Subscription event callback must be function type!!!");
    }

    if (!this.options.socketUri) {
      throw new Error(
        "Subscription event needs to add socketUri connection address!!!"
      );
    }

    this.initWebSocket(eventName).catch((e) => {
      this.eventBus[eventName].forEach((item) => {
        item[1]?.(e);
      });
    });

    if (this.eventBus[eventName]) {
      this.eventBus[eventName].push([callback, errCallback]);
    } else {
      this.eventBus[eventName] = [[callback, errCallback]];
    }
  }

  /**
   * @summary Event publishing
   * @description Client calls to publish events to event center
   * @returns
   */
  public async pub(eventName: string, data: string) {
    if (typeof eventName !== "string") {
      throw new Error("Event name must be string type!!!");
    }

    if (typeof data !== "string") {
      throw new Error("Published data must be string type!!!");
    }

    return await this.httpClient.request({
      method: "POST",
      url: "/api/v3/pub-event",
      data: {
        eventType: eventName,
        source: `${pkg.name}: ${pkg.version}`,
        eventData: data,
      },
    });
  }
}
